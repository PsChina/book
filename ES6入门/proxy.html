<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Proxy和Reflect | ECMAScript 6入门</title>
    <meta name="description" content=""/>
    <meta name="generator" content="GitBook 2.6.7"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="dir">
        
        
<div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_11">Proxy和Reflect</h1>
        
            <div class="section" id="section-">
            
                <h1 id="proxy和reflect" class="calibre6">Proxy和Reflect</h1>
<h2 id="proxy概述" class="calibre18">Proxy概述</h2>
<p class="calibre7">Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p class="calibre7">Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">target, key, receiver</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`getting <span class="hljs-operator">${key}</span>!`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);
  },
  set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">target, key, value, receiver</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`setting <span class="hljs-operator">${key}</span>!`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);
  }
});
</code></pre>
<p class="calibre7">上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code class="pcalibre3 pcalibre4 calibre14">get</code>）和设置（<code class="pcalibre3 pcalibre4 calibre14">set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code class="pcalibre3 pcalibre4 calibre14">obj</code>，去读写它的属性，就会得到下面的结果。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">obj.count = <span class="hljs-built_in">1</span>
<span class="hljs-comment">//  setting count!</span>
++obj.count
<span class="hljs-comment">//  getting count!</span>
<span class="hljs-comment">//  setting count!</span>
<span class="hljs-comment">//  2</span>
</code></pre>
<p class="calibre7">上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p class="calibre7">ES6原生提供Proxy构造函数，用来生成Proxy实例。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
</code></pre>
<p class="calibre7">Proxy对象的所有用法，都是上面这种形式，不同的只是<code class="pcalibre3 pcalibre4 calibre14">handler</code>参数的写法。其中，<code class="pcalibre3 pcalibre4 calibre14">new Proxy()</code>表示生成一个Proxy实例，target参数表示所要拦截的目标对象，<code class="pcalibre3 pcalibre4 calibre14">handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p class="calibre7">下面是另一个拦截读取属性行为的例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, property</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">35</span>;
  }
});

proxy.time <span class="hljs-comment">// 35</span>
proxy.name <span class="hljs-comment">// 35</span>
proxy.title <span class="hljs-comment">// 35</span>
</code></pre>
<p class="calibre7">上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code class="pcalibre3 pcalibre4 calibre14">get</code>方法，用来拦截对目标对象属性的访问请求。<code class="pcalibre3 pcalibre4 calibre14">get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code class="pcalibre3 pcalibre4 calibre14">35</code>，所以访问任何属性都得到<code class="pcalibre3 pcalibre4 calibre14">35</code>。</p>
<p class="calibre7">注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p class="calibre7">如果<code class="pcalibre3 pcalibre4 calibre14">handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> target = {};
<span class="hljs-keyword">var</span> handler = {};
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
proxy.a = <span class="hljs-string">'b'</span>;
target.a <span class="hljs-comment">// "b"</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">handler</code>是一个空对象，没有任何拦截效果，访问<code class="pcalibre3 pcalibre4 calibre14">handeler</code>就等同于访问<code class="pcalibre3 pcalibre4 calibre14">target</code>。</p>
<p class="calibre7">一个技巧是将Proxy对象，设置到<code class="pcalibre3 pcalibre4 calibre14">object.proxy</code>属性，从而可以在<code class="pcalibre3 pcalibre4 calibre14">object</code>对象上调用。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> object = { proxy: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler) };
</code></pre>
<p class="calibre7">Proxy实例也可以作为其他对象的原型对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, property</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">35</span>;
  }
});

<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(proxy);
obj.time <span class="hljs-comment">// 35</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">proxy</code>对象是<code class="pcalibre3 pcalibre4 calibre14">obj</code>对象的原型，<code class="pcalibre3 pcalibre4 calibre14">obj</code>对象本身并没有<code class="pcalibre3 pcalibre4 calibre14">time</code>属性，所以根据原型链，会在<code class="pcalibre3 pcalibre4 calibre14">proxy</code>对象上读取该属性，导致被拦截。</p>
<p class="calibre7">同一个拦截器函数，可以设置拦截多个操作。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, name</span>) </span>{
    <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'prototype'</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, '</span> + name;
  },
  apply: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, thisBinding, args</span>) </span>{ <span class="hljs-keyword">return</span> args[<span class="hljs-built_in">0</span>]; },
  construct: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, args</span>) </span>{ <span class="hljs-keyword">return</span> args[<span class="hljs-built_in">1</span>]; }
};

<span class="hljs-keyword">var</span> fproxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">x, y</span>) </span>{
  <span class="hljs-keyword">return</span> x + y;
}, handler);

fproxy(<span class="hljs-built_in">1</span>,<span class="hljs-built_in">2</span>); <span class="hljs-comment">// 1</span>
<span class="hljs-keyword">new</span> fproxy(<span class="hljs-built_in">1</span>,<span class="hljs-built_in">2</span>); <span class="hljs-comment">// 2</span>
fproxy.prototype; <span class="hljs-comment">// Object.prototype</span>
fproxy.foo; <span class="hljs-comment">// 'Hello, foo'</span>
</code></pre>
<p class="calibre7">下面是Proxy支持的拦截操作一览。</p>
<p class="calibre7">对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p class="calibre7"><strong class="calibre17">（1）get(target, propKey, receiver)</strong></p>
<p class="calibre7">拦截对象属性的读取，比如<code class="pcalibre3 pcalibre4 calibre14">proxy.foo</code>和<code class="pcalibre3 pcalibre4 calibre14">proxy['foo']</code>，返回类型不限。最后一个参数<code class="pcalibre3 pcalibre4 calibre14">receiver</code>可选，当<code class="pcalibre3 pcalibre4 calibre14">target</code>对象设置了<code class="pcalibre3 pcalibre4 calibre14">propKey</code>属性的<code class="pcalibre3 pcalibre4 calibre14">get</code>函数时，<code class="pcalibre3 pcalibre4 calibre14">receiver</code>对象会绑定<code class="pcalibre3 pcalibre4 calibre14">get</code>函数的<code class="pcalibre3 pcalibre4 calibre14">this</code>对象。</p>
<p class="calibre7"><strong class="calibre17">（2）set(target, propKey, value, receiver)</strong></p>
<p class="calibre7">拦截对象属性的设置，比如<code class="pcalibre3 pcalibre4 calibre14">proxy.foo = v</code>或<code class="pcalibre3 pcalibre4 calibre14">proxy['foo'] = v</code>，返回一个布尔值。</p>
<p class="calibre7"><strong class="calibre17">（3）has(target, propKey)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">propKey in proxy</code>的操作，返回一个布尔值。</p>
<p class="calibre7"><strong class="calibre17">（4）deleteProperty(target, propKey)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">delete proxy[propKey]</code>的操作，返回一个布尔值。</p>
<p class="calibre7"><strong class="calibre17">（5）enumerate(target)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">for (var x in proxy)</code>，返回一个遍历器。</p>
<p class="calibre7"><strong class="calibre17">（6）ownKeys(target)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyNames(proxy)</code>、<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertySymbols(proxy)</code>、<code class="pcalibre3 pcalibre4 calibre14">Object.keys(proxy)</code>，返回一个数组。该方法返回对象所有自身的属性，而<code class="pcalibre3 pcalibre4 calibre14">Object.keys()</code>仅返回对象可遍历的属性。</p>
<p class="calibre7"><strong class="calibre17">（7）getOwnPropertyDescriptor(target, propKey)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p>
<p class="calibre7"><strong class="calibre17">（8）defineProperty(target, propKey, propDesc)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">Object.defineProperty(proxy, propKey, propDesc）</code>、<code class="pcalibre3 pcalibre4 calibre14">Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p>
<p class="calibre7"><strong class="calibre17">（9）preventExtensions(target)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">Object.preventExtensions(proxy)</code>，返回一个布尔值。</p>
<p class="calibre7"><strong class="calibre17">（10）getPrototypeOf(target)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">Object.getPrototypeOf(proxy)</code>，返回一个对象。</p>
<p class="calibre7"><strong class="calibre17">（11）isExtensible(target)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">Object.isExtensible(proxy)</code>，返回一个布尔值。</p>
<p class="calibre7"><strong class="calibre17">（12）setPrototypeOf(target, proto)</strong></p>
<p class="calibre7">拦截<code class="pcalibre3 pcalibre4 calibre14">Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。</p>
<p class="calibre7">如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
<p class="calibre7"><strong class="calibre17">（13）apply(target, object, args)</strong></p>
<p class="calibre7">拦截Proxy实例作为函数调用的操作，比如<code class="pcalibre3 pcalibre4 calibre14">proxy(...args)</code>、<code class="pcalibre3 pcalibre4 calibre14">proxy.call(object, ...args)</code>、<code class="pcalibre3 pcalibre4 calibre14">proxy.apply(...)</code>。</p>
<p class="calibre7"><strong class="calibre17">（14）construct(target, args, proxy)</strong></p>
<p class="calibre7">拦截Proxy实例作为构造函数调用的操作，比如<code class="pcalibre3 pcalibre4 calibre14">new proxy(...args)</code>。</p>
<h2 id="proxy实例的方法" class="calibre13">Proxy实例的方法</h2>
<p class="calibre7">下面是上面这些拦截方法的详细介绍。</p>
<h3 id="get" class="calibre12">get()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">get</code>方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> person = {
  name: <span class="hljs-string">"张三"</span>
};

<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(person, {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, property</span>) </span>{
    <span class="hljs-keyword">if</span> (property <span class="hljs-keyword">in</span> target) {
      <span class="hljs-keyword">return</span> target[property];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReferenceError</span>(<span class="hljs-string">"Property \""</span> + property + <span class="hljs-string">"\" does not exist."</span>);
    }
  }
});

proxy.name <span class="hljs-comment">// "张三"</span>
proxy.age <span class="hljs-comment">// 抛出一个错误</span>
</code></pre>
<p class="calibre7">上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code class="pcalibre3 pcalibre4 calibre14">undefined</code>。</p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">get</code>方法可以继承。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> proto = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  get(target, propertyKey, receiver) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'GET '</span>+propertyKey);
    <span class="hljs-keyword">return</span> target[propertyKey];
  }
});

<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(proto);
obj.xxx <span class="hljs-comment">// "GET xxx"</span>
</code></pre>
<p class="calibre7">上面代码中，拦截操作定义在Prototype对象上面，所以如果读取<code class="pcalibre3 pcalibre4 calibre14">obj</code>对象继承的属性时，拦截会生效。</p>
<p class="calibre7">下面的例子使用<code class="pcalibre3 pcalibre4 calibre14">get</code>拦截，实现数组读取负数的索引。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">createArray</span>(<span class="hljs-built_in">...elements</span>) </span>{
  <span class="hljs-keyword">let</span> handler = {
    get(target, propKey, receiver) {
      <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">Number</span>(propKey);
      <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-built_in">0</span>) {
        propKey = <span class="hljs-built_in">String</span>(target.length + index);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, propKey, receiver);
    }
  };

  <span class="hljs-keyword">let</span> target = [];
  target.push(...elements);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
}

<span class="hljs-keyword">let</span> arr = createArray(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>);
arr[-<span class="hljs-built_in">1</span>] <span class="hljs-comment">// c</span>
</code></pre>
<p class="calibre7">上面代码中，数组的位置参数是<code class="pcalibre3 pcalibre4 calibre14">-1</code>，就会输出数组的倒数最后一个成员。</p>
<p class="calibre7">利用Proxy，可以将读取属性的操作（<code class="pcalibre3 pcalibre4 calibre14">get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> pipe = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">value</span>) </span>{
    <span class="hljs-keyword">var</span> funcStack = [];
    <span class="hljs-keyword">var</span> oproxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({} , {
      get : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">pipeObject, fnName</span>) </span>{
        <span class="hljs-keyword">if</span> (fnName === <span class="hljs-string">'get'</span>) {
          <span class="hljs-keyword">return</span> funcStack.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">val, fn</span>) </span>{
            <span class="hljs-keyword">return</span> fn(val);
          },value);
        }
        funcStack.push(<span class="hljs-built_in">window</span>[fnName]);
        <span class="hljs-keyword">return</span> oproxy;
      }
    });

    <span class="hljs-keyword">return</span> oproxy;
  }
}());

<span class="hljs-keyword">var</span> double = n =&gt; n * <span class="hljs-built_in">2</span>;
<span class="hljs-keyword">var</span> pow    = n =&gt; n * n;
<span class="hljs-keyword">var</span> reverseInt = n =&gt; n.toString().split(<span class="hljs-string">""</span>).reverse().join(<span class="hljs-string">""</span>) | <span class="hljs-built_in">0</span>;

pipe(<span class="hljs-built_in">3</span>).double.pow.reverseInt.get; <span class="hljs-comment">// 63</span>
</code></pre>
<p class="calibre7">上面代码设置Proxy以后，达到了将函数名链式使用的效果。</p>
<p class="calibre7">下面的例子则是利用<code class="pcalibre3 pcalibre4 calibre14">get</code>拦截，实现一个生成各种DOM节点的通用函数<code class="pcalibre3 pcalibre4 calibre14">dom</code>。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> dom = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  get(target, property) {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">attrs = {}, ...children</span>) </span>{
      <span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.createElement(property);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(attrs)) {
        el.setAttribute(prop, attrs[prop]);
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> child <span class="hljs-keyword">of</span> children) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child === <span class="hljs-string">'string'</span>) {
          child = <span class="hljs-built_in">document</span>.createTextNode(child);
        }
        el.appendChild(child);
      }
      <span class="hljs-keyword">return</span> el;
    }
  }
});

<span class="hljs-keyword">const</span> el = dom.div({},
  <span class="hljs-string">'Hello, my name is '</span>,
  dom.a({href: <span class="hljs-string">'//example.com'</span>}, <span class="hljs-string">'Mark'</span>),
  <span class="hljs-string">'. I like:'</span>,
  dom.ul({},
    dom.li({}, <span class="hljs-string">'The web'</span>),
    dom.li({}, <span class="hljs-string">'Food'</span>),
    dom.li({}, <span class="hljs-string">'…actually that\'s it'</span>)
  )
);

<span class="hljs-built_in">document</span>.body.appendChild(el);
</code></pre>
<h3 id="set" class="calibre12">set()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">set</code>方法用来拦截某个属性的赋值操作。</p>
<p class="calibre7">假定<code class="pcalibre3 pcalibre4 calibre14">Person</code>对象有一个<code class="pcalibre3 pcalibre4 calibre14">age</code>属性，该属性应该是一个不大于200的整数，那么可以使用<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>保证<code class="pcalibre3 pcalibre4 calibre14">age</code>的属性值符合要求。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> validator = {
  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">obj, prop, value</span>) </span>{
    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'age'</span>) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Number</span>.isInteger(value)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'The age is not an integer'</span>);
      }
      <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-built_in">200</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">'The age seems invalid'</span>);
      }
    }

    <span class="hljs-comment">// 对于age以外的属性，直接保存</span>
    obj[prop] = value;
  }
};

<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, validator);

person.age = <span class="hljs-built_in">100</span>;

person.age <span class="hljs-comment">// 100</span>
person.age = <span class="hljs-string">'young'</span> <span class="hljs-comment">// 报错</span>
person.age = <span class="hljs-built_in">300</span> <span class="hljs-comment">// 报错</span>
</code></pre>
<p class="calibre7">上面代码中，由于设置了存值函数<code class="pcalibre3 pcalibre4 calibre14">set</code>，任何不符合要求的<code class="pcalibre3 pcalibre4 calibre14">age</code>属性赋值，都会抛出一个错误。利用<code class="pcalibre3 pcalibre4 calibre14">set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新DOM。</p>
<p class="calibre7">有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code class="pcalibre3 pcalibre4 calibre14">get</code>和<code class="pcalibre3 pcalibre4 calibre14">set</code>方法，就可以做到防止这些内部属性被外部读写。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  get (target, key) {
    invariant(key, <span class="hljs-string">'get'</span>);
    <span class="hljs-keyword">return</span> target[key];
  },
  set (target, key, value) {
    invariant(key, <span class="hljs-string">'set'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>;
  }
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">invariant</span> (<span class="hljs-built_in">key, action</span>) </span>{
  <span class="hljs-keyword">if</span> (key[<span class="hljs-built_in">0</span>] === <span class="hljs-string">'_'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid attempt to <span class="hljs-operator">${action}</span> private "<span class="hljs-operator">${key}</span>" property`</span>);
  }
}
<span class="hljs-keyword">var</span> target = {};
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
proxy._prop
<span class="hljs-comment">// Error: Invalid attempt to get private "_prop" property</span>
proxy._prop = <span class="hljs-string">'c'</span>
<span class="hljs-comment">// Error: Invalid attempt to set private "_prop" property</span>
</code></pre>
<p class="calibre7">上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<h3 id="apply" class="calibre12">apply()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">apply</code>方法拦截函数的调用、call和apply操作。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  apply (target, ctx, args) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.apply(...arguments);
  }
};
</code></pre>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code class="pcalibre3 pcalibre4 calibre14">this</code>）和目标对象的参数数组。</p>
<p class="calibre7">下面是一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> target = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'I am the target'</span>; };
<span class="hljs-keyword">var</span> handler = {
  apply: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'I am the proxy'</span>;
  }
};

<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);

p()
<span class="hljs-comment">// "I am the proxy"</span>
</code></pre>
<p class="calibre7">上面代码中，变量<code class="pcalibre3 pcalibre4 calibre14">p</code>是Proxy的实例，当它作为函数调用时（<code class="pcalibre3 pcalibre4 calibre14">p()</code>），就会被<code class="pcalibre3 pcalibre4 calibre14">apply</code>方法拦截，返回一个字符串。</p>
<p class="calibre7">下面是另外一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> twice = {
  apply (target, ctx, args) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.apply(...arguments) * <span class="hljs-built_in">2</span>;
  }
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">sum</span> (<span class="hljs-built_in">left, right</span>) </span>{
  <span class="hljs-keyword">return</span> left + right;
};
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(sum, twice);
proxy(<span class="hljs-built_in">1</span>, <span class="hljs-built_in">2</span>) <span class="hljs-comment">// 6</span>
proxy.call(<span class="hljs-built_in">null</span>, <span class="hljs-built_in">5</span>, <span class="hljs-built_in">6</span>) <span class="hljs-comment">// 22</span>
proxy.apply(<span class="hljs-built_in">null</span>, [<span class="hljs-built_in">7</span>, <span class="hljs-built_in">8</span>]) <span class="hljs-comment">// 30</span>
</code></pre>
<p class="calibre7">上面代码中，每当执行<code class="pcalibre3 pcalibre4 calibre14">proxy</code>函数（直接调用或<code class="pcalibre3 pcalibre4 calibre14">call</code>和<code class="pcalibre3 pcalibre4 calibre14">apply</code>调用），就会被<code class="pcalibre3 pcalibre4 calibre14">apply</code>方法拦截。</p>
<p class="calibre7">另外，直接调用<code class="pcalibre3 pcalibre4 calibre14">Reflect.apply</code>方法，也会被拦截。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Reflect</span>.apply(proxy, <span class="hljs-built_in">null</span>, [<span class="hljs-built_in">9</span>, <span class="hljs-built_in">10</span>]) <span class="hljs-comment">// 38</span>
</code></pre>
<h3 id="has" class="calibre12">has()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">has</code>方法可以隐藏某些属性，不被<code class="pcalibre3 pcalibre4 calibre14">in</code>操作符发现。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  has (target, key) {
    <span class="hljs-keyword">if</span> (key[<span class="hljs-built_in">0</span>] === <span class="hljs-string">'_'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>;
    }
    <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> target;
  }
};
<span class="hljs-keyword">var</span> target = { _prop: <span class="hljs-string">'foo'</span>, prop: <span class="hljs-string">'foo'</span> };
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-string">'_prop'</span> <span class="hljs-keyword">in</span> proxy <span class="hljs-comment">// false</span>
</code></pre>
<p class="calibre7">上面代码中，如果原对象的属性名的第一个字符是下划线，<code class="pcalibre3 pcalibre4 calibre14">proxy.has</code>就会返回<code class="pcalibre3 pcalibre4 calibre14">false</code>，从而不会被<code class="pcalibre3 pcalibre4 calibre14">in</code>运算符发现。</p>
<p class="calibre7">如果原对象不可配置或者禁止扩展，这时<code class="pcalibre3 pcalibre4 calibre14">has</code>拦截会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = { a: <span class="hljs-built_in">10</span> };
<span class="hljs-built_in">Object</span>.preventExtensions(obj);
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {
  has: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, prop</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>;
  }
});

<span class="hljs-string">"a"</span> <span class="hljs-keyword">in</span> p <span class="hljs-comment">// TypeError is thrown</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">obj</code>对象禁止扩展，结果使用<code class="pcalibre3 pcalibre4 calibre14">has</code>拦截就会报错。</p>
<h3 id="construct" class="calibre12">construct()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">construct</code>方法用于拦截<code class="pcalibre3 pcalibre4 calibre14">new</code>命令。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  construct (target, args) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> target(...args);
  }
};
</code></pre>
<p class="calibre7">下面是一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{}, {
  construct: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, args</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'called: '</span> + args.join(<span class="hljs-string">', '</span>));
    <span class="hljs-keyword">return</span> { value: args[<span class="hljs-built_in">0</span>] * <span class="hljs-built_in">10</span> };
  }
});

<span class="hljs-keyword">new</span> p(<span class="hljs-built_in">1</span>).value
<span class="hljs-comment">// "called: 1"</span>
<span class="hljs-comment">// 10</span>
</code></pre>
<p class="calibre7">如果<code class="pcalibre3 pcalibre4 calibre14">construct</code>方法返回的不是对象，就会抛出错误。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{}, {
  construct: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, argumentsList</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">1</span>;
  }
});

<span class="hljs-keyword">new</span> p() <span class="hljs-comment">// 报错</span>
</code></pre>
<h3 id="deleteproperty" class="calibre12">deleteProperty()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">deleteProperty</code>方法用于拦截<code class="pcalibre3 pcalibre4 calibre14">delete</code>操作，如果这个方法抛出错误或者返回<code class="pcalibre3 pcalibre4 calibre14">false</code>，当前属性就无法被<code class="pcalibre3 pcalibre4 calibre14">delete</code>命令删除。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  deleteProperty (target, key) {
    invariant(key, <span class="hljs-string">'delete'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>;
  }
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">invariant</span> (<span class="hljs-built_in">key, action</span>) </span>{
  <span class="hljs-keyword">if</span> (key[<span class="hljs-built_in">0</span>] === <span class="hljs-string">'_'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid attempt to <span class="hljs-operator">${action}</span> private "<span class="hljs-operator">${key}</span>" property`</span>);
  }
}

<span class="hljs-keyword">var</span> target = { _prop: <span class="hljs-string">'foo'</span> };
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-keyword">delete</span> proxy._prop
<span class="hljs-comment">// Error: Invalid attempt to delete private "_prop" property</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">deleteProperty</code>方法拦截了<code class="pcalibre3 pcalibre4 calibre14">delete</code>操作符，删除第一个字符为下划线的属性会报错。</p>
<h3 id="defineproperty" class="calibre12">defineProperty()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">defineProperty</code>方法拦截了<code class="pcalibre3 pcalibre4 calibre14">Object.defineProperty</code>操作。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  defineProperty (target, key, descriptor) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>;
  }
};
<span class="hljs-keyword">var</span> target = {};
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
proxy.foo = <span class="hljs-string">'bar'</span>
<span class="hljs-comment">// TypeError: proxy defineProperty handler returned false for property '"foo"'</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">defineProperty</code>方法返回<code class="pcalibre3 pcalibre4 calibre14">false</code>，导致添加新属性会抛出错误。</p>
<h3 id="enumerate" class="calibre12">enumerate()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">enumerate</code>方法用来拦截<code class="pcalibre3 pcalibre4 calibre14">for...in</code>循环。注意与Proxy对象的<code class="pcalibre3 pcalibre4 calibre14">has</code>方法区分，后者用来拦截<code class="pcalibre3 pcalibre4 calibre14">in</code>操作符，对<code class="pcalibre3 pcalibre4 calibre14">for...in</code>循环无效。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  enumerate (target) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(target).filter(key =&gt; key[<span class="hljs-built_in">0</span>] !== <span class="hljs-string">'_'</span>)[<span class="hljs-built_in">Symbol</span>.iterator]();
  }
};
<span class="hljs-keyword">var</span> target = { prop: <span class="hljs-string">'foo'</span>, _bar: <span class="hljs-string">'baz'</span>, _prop: <span class="hljs-string">'foo'</span> };
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> proxy) {
  <span class="hljs-built_in">console</span>.log(key);
  <span class="hljs-comment">// "prop"</span>
}
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">enumerate</code>方法取出原对象的所有属性名，将其中第一个字符等于下划线的都过滤掉，然后返回这些符合条件的属性名的一个遍历器对象，供<code class="pcalibre3 pcalibre4 calibre14">for...in</code>循环消费。</p>
<p class="calibre7">下面是另一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  enumerate(target) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"called"</span>);
    <span class="hljs-keyword">return</span> [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>][<span class="hljs-built_in">Symbol</span>.iterator]();
  }
});

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> p) {
  <span class="hljs-built_in">console</span>.log(x);
}
<span class="hljs-comment">// "called"</span>
<span class="hljs-comment">// "a"</span>
<span class="hljs-comment">// "b"</span>
<span class="hljs-comment">// "c"</span>
</code></pre>
<p class="calibre7">如果<code class="pcalibre3 pcalibre4 calibre14">enumerate</code>方法返回的不是一个对象，就会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  enumerate(target) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">1</span>;
  }
});

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">in</span> p) {} <span class="hljs-comment">// 报错</span>
</code></pre>
<h3 id="getownpropertydescriptor" class="calibre12">getOwnPropertyDescriptor()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">getOwnPropertyDescriptor</code>方法拦截<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptor</code>，返回一个属性描述对象或者<code class="pcalibre3 pcalibre4 calibre14">undefined</code>。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  getOwnPropertyDescriptor (target, key) {
    <span class="hljs-keyword">if</span> (key[<span class="hljs-built_in">0</span>] === <span class="hljs-string">'_'</span>) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target, key);
  }
};
<span class="hljs-keyword">var</span> target = { _foo: <span class="hljs-string">'bar'</span>, baz: <span class="hljs-string">'tar'</span> };
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="hljs-string">'wat'</span>)
<span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="hljs-string">'_foo'</span>)
<span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="hljs-string">'baz'</span>)
<span class="hljs-comment">// { value: 'tar', writable: true, enumerable: true, configurable: true }</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">handler.getOwnPropertyDescriptor</code>方法对于第一个字符为下划线的属性名会返回<code class="pcalibre3 pcalibre4 calibre14">undefined</code>。</p>
<h3 id="getprototypeof" class="calibre12">getPrototypeOf()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">getPrototypeOf</code>方法主要用来拦截<code class="pcalibre3 pcalibre4 calibre14">Object.getPrototypeOf()</code>运算符，以及其他一些操作。</p>
<ul class="calibre10">
<li class="calibre11"><code class="pcalibre3 pcalibre4 calibre14">Object.prototype.__proto__</code></li>
<li class="calibre11"><code class="pcalibre3 pcalibre4 calibre14">Object.prototype.isPrototypeOf()</code></li>
<li class="calibre11"><code class="pcalibre3 pcalibre4 calibre14">Object.getPrototypeOf()</code></li>
<li class="calibre11"><code class="pcalibre3 pcalibre4 calibre14">Reflect.getPrototypeOf()</code></li>
<li class="calibre11"><code class="pcalibre3 pcalibre4 calibre14">instanceof</code>运算符</li>
</ul>
<p class="calibre7">下面是一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> proto = {};
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  getPrototypeOf(target) {
    <span class="hljs-keyword">return</span> proto;
  }
});
<span class="hljs-built_in">Object</span>.getPrototypeOf(p) === proto <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">getPrototypeOf</code>方法拦截<code class="pcalibre3 pcalibre4 calibre14">Object.getPrototypeOf()</code>，返回<code class="pcalibre3 pcalibre4 calibre14">proto</code>对象。</p>
<h3 id="isextensible" class="calibre12">isExtensible()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">isExtensible</code>方法拦截<code class="pcalibre3 pcalibre4 calibre14">Object.isExtensible</code>操作。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  isExtensible: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"called"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>;
  }
});

<span class="hljs-built_in">Object</span>.isExtensible(p)
<span class="hljs-comment">// "called"</span>
<span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre7">上面代码设置了<code class="pcalibre3 pcalibre4 calibre14">isExtensible</code>方法，在调用<code class="pcalibre3 pcalibre4 calibre14">Object.isExtensible</code>时会输出<code class="pcalibre3 pcalibre4 calibre14">called</code>。</p>
<p class="calibre7">这个方法有一个强限制，如果不能满足下面的条件，就会抛出错误。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.isExtensible(proxy) === <span class="hljs-built_in">Object</span>.isExtensible(target)
</code></pre>
<p class="calibre7">下面是一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  isExtensible: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>;
  }
});

<span class="hljs-built_in">Object</span>.isExtensible(p) <span class="hljs-comment">// 报错</span>
</code></pre>
<h3 id="ownkeys" class="calibre12">ownKeys()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">ownKeys</code>方法用来拦截<code class="pcalibre3 pcalibre4 calibre14">Object.keys()</code>操作。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> target = {};

<span class="hljs-keyword">let</span> handler = {
  ownKeys(target) {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
  }
};

<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);

<span class="hljs-built_in">Object</span>.keys(proxy)
<span class="hljs-comment">// [ 'hello', 'world' ]</span>
</code></pre>
<p class="calibre7">上面代码拦截了对于<code class="pcalibre3 pcalibre4 calibre14">target</code>对象的<code class="pcalibre3 pcalibre4 calibre14">Object.keys()</code>操作，返回预先设定的数组。</p>
<p class="calibre7">下面的例子是拦截第一个字符为下划线的属性名。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> target = {
  _bar: <span class="hljs-string">'foo'</span>,
  _prop: <span class="hljs-string">'bar'</span>,
  prop: <span class="hljs-string">'baz'</span>
};

<span class="hljs-keyword">var</span> handler = {
  ownKeys (target) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.ownKeys(target).filter(key =&gt; key[<span class="hljs-built_in">0</span>] !== <span class="hljs-string">'_'</span>);
  }
};

<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(proxy)) {
  <span class="hljs-built_in">console</span>.log(key)
}
<span class="hljs-comment">// "baz"</span>
</code></pre>
<h3 id="preventextensions" class="calibre12">preventExtensions()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">preventExtensions</code>方法拦截<code class="pcalibre3 pcalibre4 calibre14">Object.preventExtensions()</code>。该方法必须返回一个布尔值。</p>
<p class="calibre7">这个方法有一个限制，只有当<code class="pcalibre3 pcalibre4 calibre14">Object.isExtensible(proxy)</code>为<code class="pcalibre3 pcalibre4 calibre14">false</code>（即不可扩展）时，<code class="pcalibre3 pcalibre4 calibre14">proxy.preventExtensions</code>才能返回<code class="pcalibre3 pcalibre4 calibre14">true</code>，否则会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  preventExtensions: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>;
  }
});

<span class="hljs-built_in">Object</span>.preventExtensions(p) <span class="hljs-comment">// 报错</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">proxy.preventExtensions</code>方法返回<code class="pcalibre3 pcalibre4 calibre14">true</code>，但这时<code class="pcalibre3 pcalibre4 calibre14">Object.isExtensible(proxy)</code>会返回<code class="pcalibre3 pcalibre4 calibre14">true</code>，因此报错。</p>
<p class="calibre7">为了防止出现这个问题，通常要在<code class="pcalibre3 pcalibre4 calibre14">proxy.preventExtensions</code>方法里面，调用一次<code class="pcalibre3 pcalibre4 calibre14">Object.preventExtensions</code>。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
  preventExtensions: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"called"</span>);
    <span class="hljs-built_in">Object</span>.preventExtensions(target);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>;
  }
});

<span class="hljs-built_in">Object</span>.preventExtensions(p)
<span class="hljs-comment">// "called"</span>
<span class="hljs-comment">// true</span>
</code></pre>
<h3 id="setprototypeof" class="calibre12">setPrototypeOf()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">setPrototypeOf</code>方法主要用来拦截<code class="pcalibre3 pcalibre4 calibre14">Object.setPrototypeOf</code>方法。</p>
<p class="calibre7">下面是一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> handler = {
  setPrototypeOf (target, proto) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Changing the prototype is forbidden'</span>);
  }
};
<span class="hljs-keyword">var</span> proto = {};
<span class="hljs-keyword">var</span> target = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>) </span>{};
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
proxy.setPrototypeOf(proxy, proto);
<span class="hljs-comment">// Error: Changing the prototype is forbidden</span>
</code></pre>
<p class="calibre7">上面代码中，只要修改<code class="pcalibre3 pcalibre4 calibre14">target</code>的原型对象，就会报错。</p>
<h2 id="proxyrevocable" class="calibre13">Proxy.revocable()</h2>
<p class="calibre7">Proxy.revocable方法返回一个可取消的Proxy实例。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> target = {};
<span class="hljs-keyword">let</span> handler = {};

<span class="hljs-keyword">let</span> {proxy, revoke} = <span class="hljs-built_in">Proxy</span>.revocable(target, handler);

proxy.foo = <span class="hljs-built_in">123</span>;
proxy.foo <span class="hljs-comment">// 123</span>

revoke();
proxy.foo <span class="hljs-comment">// TypeError: Revoked</span>
</code></pre>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Proxy.revocable</code>方法返回一个对象，该对象的<code class="pcalibre3 pcalibre4 calibre14">proxy</code>属性是<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>实例，<code class="pcalibre3 pcalibre4 calibre14">revoke</code>属性是一个函数，可以取消<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>实例。上面代码中，当执行<code class="pcalibre3 pcalibre4 calibre14">revoke</code>函数之后，再访问<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>实例，就会抛出一个错误。</p>
<h2 id="reflect概述" class="calibre13">Reflect概述</h2>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象与<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>对象一样，也是ES6为了操作对象而提供的新API。<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象的设计目的有这样几个。</p>
<p class="calibre7">（1） 将<code class="pcalibre3 pcalibre4 calibre14">Object</code>对象的一些明显属于语言内部的方法（比如<code class="pcalibre3 pcalibre4 calibre14">Object.defineProperty</code>），放到<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象上。现阶段，某些方法同时在<code class="pcalibre3 pcalibre4 calibre14">Object</code>和<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象上部署，未来的新方法将只部署在<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象上。</p>
<p class="calibre7">（2） 修改某些Object方法的返回结果，让其变得更合理。比如，<code class="pcalibre3 pcalibre4 calibre14">Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code class="pcalibre3 pcalibre4 calibre14">Reflect.defineProperty(obj, name, desc)</code>则会返回<code class="pcalibre3 pcalibre4 calibre14">false</code>。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 老写法</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-built_in">Object</span>.defineProperty(target, property, attributes);
  <span class="hljs-comment">// success</span>
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-comment">// failure</span>
}

<span class="hljs-comment">// 新写法</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.defineProperty(target, property, attributes)) {
  <span class="hljs-comment">// success</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// failure</span>
}
</code></pre>
<p class="calibre7">（3） 让<code class="pcalibre3 pcalibre4 calibre14">Object</code>操作都变成函数行为。某些<code class="pcalibre3 pcalibre4 calibre14">Object</code>操作是命令式，比如<code class="pcalibre3 pcalibre4 calibre14">name in obj</code>和<code class="pcalibre3 pcalibre4 calibre14">delete obj[name]</code>，而<code class="pcalibre3 pcalibre4 calibre14">Reflect.has(obj, name)</code>和<code class="pcalibre3 pcalibre4 calibre14">Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 老写法</span>
<span class="hljs-string">'assign'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-built_in">Reflect</span>.has(<span class="hljs-built_in">Object</span>, <span class="hljs-string">'assign'</span>) <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre7">（4）<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象的方法与<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>对象的方法一一对应，只要是<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>对象的方法，就能在<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象上找到对应的方法。这就让<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>对象可以方便地调用对应的<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>怎么修改默认行为，你总可以在<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>上获取默认行为。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Proxy</span>(target, {
  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">target, name, value, receiver</span>) </span>{
    <span class="hljs-keyword">var</span> success = <span class="hljs-built_in">Reflect</span>.set(target,name, value, receiver);
    <span class="hljs-keyword">if</span> (success) {
      log(<span class="hljs-string">'property '</span> + name + <span class="hljs-string">' on '</span> + target + <span class="hljs-string">' set to '</span> + value);
    }
    <span class="hljs-keyword">return</span> success;
  }
});
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>方法拦截<code class="pcalibre3 pcalibre4 calibre14">target</code>对象的属性赋值行为。它采用<code class="pcalibre3 pcalibre4 calibre14">Reflect.set</code>方法将值赋值给对象的属性，然后再部署额外的功能。</p>
<p class="calibre7">下面是另一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> loggedObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {
  get(target, name) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'get'</span>, target, name);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, name);
  },
  deleteProperty(target, name) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'delete'</span> + name);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.deleteProperty(target, name);
  },
  has(target, name) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'has'</span> + name);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.has(target, name);
  }
});
</code></pre>
<p class="calibre7">上面代码中，每一个<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>对象的拦截操作（<code class="pcalibre3 pcalibre4 calibre14">get</code>、<code class="pcalibre3 pcalibre4 calibre14">delete</code>、<code class="pcalibre3 pcalibre4 calibre14">has</code>），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
<p class="calibre7">有了<code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象以后，很多操作会更易读。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 老写法</span>
<span class="hljs-built_in">Function</span>.prototype.apply.call(<span class="hljs-built_in">Math</span>.floor, <span class="hljs-built_in">undefined</span>, [<span class="hljs-built_in">1.75</span>]) <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// 新写法</span>
<span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Math</span>.floor, <span class="hljs-built_in">undefined</span>, [<span class="hljs-built_in">1.75</span>]) <span class="hljs-comment">// 1</span>
</code></pre>
<h2 id="reflect对象的方法" class="calibre13">Reflect对象的方法</h2>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Reflect</code>对象的方法清单如下，共14个。</p>
<ul class="calibre10">
<li class="calibre11">Reflect.apply(target,thisArg,args)</li>
<li class="calibre11">Reflect.construct(target,args)</li>
<li class="calibre11">Reflect.get(target,name,receiver)</li>
<li class="calibre11">Reflect.set(target,name,value,receiver)</li>
<li class="calibre11">Reflect.defineProperty(target,name,desc)</li>
<li class="calibre11">Reflect.deleteProperty(target,name)</li>
<li class="calibre11">Reflect.has(target,name)</li>
<li class="calibre11">Reflect.ownKeys(target)</li>
<li class="calibre11">Reflect.enumerate(target)</li>
<li class="calibre11">Reflect.isExtensible(target)</li>
<li class="calibre11">Reflect.preventExtensions(target)</li>
<li class="calibre11">Reflect.getOwnPropertyDescriptor(target, name)</li>
<li class="calibre11">Reflect.getPrototypeOf(target)</li>
<li class="calibre11">Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p class="calibre7">上面这些方法的作用，大部分与<code class="pcalibre3 pcalibre4 calibre14">Object</code>对象的同名方法的作用都是相同的，而且它与<code class="pcalibre3 pcalibre4 calibre14">Proxy</code>对象的方法是一一对应的。下面是对其中几个方法的解释。</p>
<p class="calibre7"><strong class="calibre17">（1）Reflect.get(target, name, receiver)</strong></p>
<p class="calibre7">查找并返回<code class="pcalibre3 pcalibre4 calibre14">target</code>对象的<code class="pcalibre3 pcalibre4 calibre14">name</code>属性，如果没有该属性，则返回<code class="pcalibre3 pcalibre4 calibre14">undefined</code>。</p>
<p class="calibre7">如果<code class="pcalibre3 pcalibre4 calibre14">name</code>属性部署了读取函数，则读取函数的this绑定<code class="pcalibre3 pcalibre4 calibre14">receiver</code>。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = {
  get foo() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bar(); },
  bar: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{ ... }
};

<span class="hljs-comment">// 下面语句会让 this.bar()</span>
<span class="hljs-comment">// 变成调用 wrapper.bar()</span>
<span class="hljs-built_in">Reflect</span>.get(obj, <span class="hljs-string">"foo"</span>, wrapper);
</code></pre>
<p class="calibre7"><strong class="calibre17">（2）Reflect.set(target, name, value, receiver)</strong></p>
<p class="calibre7">设置<code class="pcalibre3 pcalibre4 calibre14">target</code>对象的<code class="pcalibre3 pcalibre4 calibre14">name</code>属性等于<code class="pcalibre3 pcalibre4 calibre14">value</code>。如果<code class="pcalibre3 pcalibre4 calibre14">name</code>属性设置了赋值函数，则赋值函数的<code class="pcalibre3 pcalibre4 calibre14">this</code>绑定<code class="pcalibre3 pcalibre4 calibre14">receiver</code>。</p>
<p class="calibre7"><strong class="calibre17">（3）Reflect.has(obj, name)</strong></p>
<p class="calibre7">等同于<code class="pcalibre3 pcalibre4 calibre14">name in obj</code>。</p>
<p class="calibre7"><strong class="calibre17">（4）Reflect.deleteProperty(obj, name)</strong></p>
<p class="calibre7">等同于<code class="pcalibre3 pcalibre4 calibre14">delete obj[name]</code>。</p>
<p class="calibre7"><strong class="calibre17">（5）Reflect.construct(target, args)</strong></p>
<p class="calibre7">等同于<code class="pcalibre3 pcalibre4 calibre14">new target(...args)</code>，这提供了一种不使用<code class="pcalibre3 pcalibre4 calibre14">new</code>，来调用构造函数的方法。</p>
<p class="calibre7"><strong class="calibre17">（6）Reflect.getPrototypeOf(obj)</strong></p>
<p class="calibre7">读取对象的<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>属性，对应<code class="pcalibre3 pcalibre4 calibre14">Object.getPrototypeOf(obj)</code>。</p>
<p class="calibre7"><strong class="calibre17">（7）Reflect.setPrototypeOf(obj, newProto)</strong></p>
<p class="calibre7">设置对象的<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>属性，对应<code class="pcalibre3 pcalibre4 calibre14">Object.setPrototypeOf(obj, newProto)</code>。</p>
<p class="calibre7"><strong class="calibre17">（8）Reflect.apply(fun,thisArg,args)</strong></p>
<p class="calibre7">等同于<code class="pcalibre3 pcalibre4 calibre14">Function.prototype.apply.call(fun,thisArg,args)</code>。一般来说，如果要绑定一个函数的this对象，可以这样写<code class="pcalibre3 pcalibre4 calibre14">fn.apply(obj, args)</code>，但是如果函数定义了自己的<code class="pcalibre3 pcalibre4 calibre14">apply</code>方法，就只能写成<code class="pcalibre3 pcalibre4 calibre14">Function.prototype.apply.call(fn, obj, args)</code>，采用Reflect对象可以简化这种操作。</p>
<p class="calibre7">另外，需要注意的是，<code class="pcalibre3 pcalibre4 calibre14">Reflect.set()</code>、<code class="pcalibre3 pcalibre4 calibre14">Reflect.defineProperty()</code>、<code class="pcalibre3 pcalibre4 calibre14">Reflect.freeze()</code>、<code class="pcalibre3 pcalibre4 calibre14">Reflect.seal()</code>和<code class="pcalibre3 pcalibre4 calibre14">Reflect.preventExtensions()</code>返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 失败时抛出错误</span>
<span class="hljs-built_in">Object</span>.defineProperty(obj, name, desc);
<span class="hljs-comment">// 失败时返回false</span>
<span class="hljs-built_in">Reflect</span>.defineProperty(obj, name, desc);
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">Reflect.defineProperty</code>方法的作用与<code class="pcalibre3 pcalibre4 calibre14">Object.defineProperty</code>是一样的，都是为对象定义一个属性。但是，<code class="pcalibre3 pcalibre4 calibre14">Reflect.defineProperty</code>方法失败时，不会抛出错误，只会返回<code class="pcalibre3 pcalibre4 calibre14">false</code>。</p>

            
            </div>
        
    
</div>

        
        
    
    

</body></html>
