<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>对象的扩展 | ECMAScript 6入门</title>
    <meta name="description" content=""/>
    <meta name="generator" content="GitBook 2.6.7"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="dir">
        
        
<div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_9">对象的扩展</h1>
        
            <div class="section" id="section-">
            
                <h1 id="对象的扩展" class="calibre6">对象的扩展</h1>
<h2 id="属性的简洁表示法" class="calibre18">属性的简洁表示法</h2>
<p class="calibre7">ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">'bar'</span>;
<span class="hljs-keyword">var</span> baz = {foo};
baz <span class="hljs-comment">// {foo: "bar"}</span>

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">var</span> baz = {foo: foo};
</code></pre>
<p class="calibre7">上面代码表明，ES6允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。下面是另一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">f</span>(<span class="hljs-built_in">x, y</span>) </span>{
  <span class="hljs-keyword">return</span> {x, y};
}

<span class="hljs-comment">// 等同于</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">f</span>(<span class="hljs-built_in">x, y</span>) </span>{
  <span class="hljs-keyword">return</span> {x: x, y: y};
}

f(<span class="hljs-built_in">1</span>, <span class="hljs-built_in">2</span>) <span class="hljs-comment">// Object {x: 1, y: 2}</span>
</code></pre>
<p class="calibre7">除了属性简写，方法也可以简写。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> o = {
  method() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello!"</span>;
  }
};

<span class="hljs-comment">// 等同于</span>

<span class="hljs-keyword">var</span> o = {
  method: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello!"</span>;
  }
};
</code></pre>
<p class="calibre7">下面是一个实际的例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> birth = <span class="hljs-string">'2000/01/01'</span>;

<span class="hljs-keyword">var</span> Person = {

  name: <span class="hljs-string">'张三'</span>,

  <span class="hljs-comment">//等同于birth: birth</span>
  birth,

  <span class="hljs-comment">// 等同于hello: function ()...</span>
  hello() { <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我的名字是'</span>, <span class="hljs-keyword">this</span>.name); }

};
</code></pre>
<p class="calibre7">这种写法用于函数的返回值，将会非常方便。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">getPoint</span>(<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-keyword">var</span> x = <span class="hljs-built_in">1</span>;
  <span class="hljs-keyword">var</span> y = <span class="hljs-built_in">10</span>;
  <span class="hljs-keyword">return</span> {x, y};
}

getPoint()
<span class="hljs-comment">// {x:1, y:10}</span>
</code></pre>
<p class="calibre7">CommonJS模块输出变量，就非常合适使用简洁写法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> ms = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">getItem</span> (<span class="hljs-built_in">key</span>) </span>{
  <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> ms ? ms[key] : <span class="hljs-built_in">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">setItem</span> (<span class="hljs-built_in">key, value</span>) </span>{
  ms[key] = value;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">clear</span> (<span class="hljs-built_in"></span>) </span>{
  ms = {};
}

<span class="hljs-built_in">module</span>.exports = { getItem, setItem, clear };
<span class="hljs-comment">// 等同于</span>
<span class="hljs-built_in">module</span>.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
</code></pre>
<p class="calibre7">属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> cart = {
  _wheels: <span class="hljs-built_in">4</span>,

  get wheels () {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._wheels;
  },

  set wheels (value) {
    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-keyword">this</span>._wheels) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'数值太小了！'</span>);
    }
    <span class="hljs-keyword">this</span>._wheels = value;
  }
}
</code></pre>
<p class="calibre7">注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-operator"><span class="hljs-keyword">class</span> () </span>{}
};

<span class="hljs-comment">// 等同于</span>

<span class="hljs-keyword">var</span> obj = {
  <span class="hljs-string">'class'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{}
};
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">class</code>是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<p class="calibre7">如果某个方法的值是一个Generator函数，前面需要加上星号。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = {
  * m(){
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello world'</span>;
  }
};
</code></pre>
<h2 id="属性名表达式" class="calibre13">属性名表达式</h2>
<p class="calibre7">JavaScript语言定义对象的属性，有两种方法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 方法一</span>
obj.foo = <span class="hljs-built_in">true</span>;

<span class="hljs-comment">// 方法二</span>
obj[<span class="hljs-string">'a'</span> + <span class="hljs-string">'bc'</span>] = <span class="hljs-built_in">123</span>;
</code></pre>
<p class="calibre7">上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p class="calibre7">但是，如果使用字面量方式定义对象（使用大括号），在ES5中只能使用方法一（标识符）定义属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = {
  foo: <span class="hljs-built_in">true</span>,
  abc: <span class="hljs-built_in">123</span>
};
</code></pre>
<p class="calibre7">ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> propKey = <span class="hljs-string">'foo'</span>;

<span class="hljs-keyword">let</span> obj = {
  [propKey]: <span class="hljs-built_in">true</span>,
  [<span class="hljs-string">'a'</span> + <span class="hljs-string">'bc'</span>]: <span class="hljs-built_in">123</span>
};
</code></pre>
<p class="calibre7">下面是另一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> lastWord = <span class="hljs-string">'last word'</span>;

<span class="hljs-keyword">var</span> a = {
  <span class="hljs-string">'first word'</span>: <span class="hljs-string">'hello'</span>,
  [lastWord]: <span class="hljs-string">'world'</span>
};

a[<span class="hljs-string">'first word'</span>] <span class="hljs-comment">// "hello"</span>
a[lastWord] <span class="hljs-comment">// "world"</span>
a[<span class="hljs-string">'last word'</span>] <span class="hljs-comment">// "world"</span>
</code></pre>
<p class="calibre7">表达式还可以用于定义方法名。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> obj = {
  [<span class="hljs-string">'h'</span>+<span class="hljs-string">'ello'</span>]() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'hi'</span>;
  }
};

obj.hello() <span class="hljs-comment">// hi</span>
</code></pre>
<p class="calibre7">注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">'bar'</span>;
<span class="hljs-keyword">var</span> bar = <span class="hljs-string">'abc'</span>;
<span class="hljs-keyword">var</span> baz = { [foo] };

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">'bar'</span>;
<span class="hljs-keyword">var</span> baz = { [foo]: <span class="hljs-string">'abc'</span>};
</code></pre>
<h2 id="方法的name属性" class="calibre13">方法的name属性</h2>
<p class="calibre7">函数的<code class="pcalibre3 pcalibre4 calibre14">name</code>属性，返回函数名。对象方法也是函数，因此也有<code class="pcalibre3 pcalibre4 calibre14">name</code>属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> person = {
  sayName() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
  },
  get firstName() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Nicholas"</span>;
  }
};

person.sayName.name   <span class="hljs-comment">// "sayName"</span>
person.firstName.name <span class="hljs-comment">// "get firstName"</span>
</code></pre>
<p class="calibre7">上面代码中，方法的<code class="pcalibre3 pcalibre4 calibre14">name</code>属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上<code class="pcalibre3 pcalibre4 calibre14">get</code>。如果是存值函数，方法名的前面会加上<code class="pcalibre3 pcalibre4 calibre14">set</code>。</p>
<p class="calibre7">有两种特殊情况：<code class="pcalibre3 pcalibre4 calibre14">bind</code>方法创造的函数，<code class="pcalibre3 pcalibre4 calibre14">name</code>属性返回“bound”加上原函数的名字；<code class="pcalibre3 pcalibre4 calibre14">Function</code>构造函数创造的函数，<code class="pcalibre3 pcalibre4 calibre14">name</code>属性返回“anonymous”。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>()).name <span class="hljs-comment">// "anonymous"</span>

<span class="hljs-keyword">var</span> doSomething = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-comment">// ...</span>
};
doSomething.bind().name <span class="hljs-comment">// "bound doSomething"</span>
</code></pre>
<p class="calibre7">如果对象的方法是一个Symbol值，那么<code class="pcalibre3 pcalibre4 calibre14">name</code>属性返回的是这个Symbol值的描述。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> key1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'description'</span>);
<span class="hljs-keyword">const</span> key2 = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">let</span> obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name <span class="hljs-comment">// "[description]"</span>
obj[key2].name <span class="hljs-comment">// ""</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">key1</code>对应的Symbol值有描述，<code class="pcalibre3 pcalibre4 calibre14">key2</code>没有。</p>
<h2 id="objectis" class="calibre13">Object.is()</h2>
<p class="calibre7">ES5比较两个值是否相等，只有两个运算符：相等运算符（<code class="pcalibre3 pcalibre4 calibre14">==</code>）和严格相等运算符（<code class="pcalibre3 pcalibre4 calibre14">===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code class="pcalibre3 pcalibre4 calibre14">NaN</code>不等于自身，以及<code class="pcalibre3 pcalibre4 calibre14">+0</code>等于<code class="pcalibre3 pcalibre4 calibre14">-0</code>。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p class="calibre7">ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code class="pcalibre3 pcalibre4 calibre14">Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.is(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>)
<span class="hljs-comment">// true</span>
<span class="hljs-built_in">Object</span>.is({}, {})
<span class="hljs-comment">// false</span>
</code></pre>
<p class="calibre7">不同之处只有两个：一是<code class="pcalibre3 pcalibre4 calibre14">+0</code>不等于<code class="pcalibre3 pcalibre4 calibre14">-0</code>，二是<code class="pcalibre3 pcalibre4 calibre14">NaN</code>等于自身。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">+<span class="hljs-built_in">0</span> === -<span class="hljs-built_in">0</span> <span class="hljs-comment">//true</span>
<span class="hljs-built_in">NaN</span> === <span class="hljs-built_in">NaN</span> <span class="hljs-comment">// false</span>

<span class="hljs-built_in">Object</span>.is(+<span class="hljs-built_in">0</span>, -<span class="hljs-built_in">0</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">Object</span>.is(<span class="hljs-built_in">NaN</span>, <span class="hljs-built_in">NaN</span>) <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre7">ES5可以通过下面的代码，部署<code class="pcalibre3 pcalibre4 calibre14">Object.is</code>。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Object</span>, <span class="hljs-string">'is'</span>, {
  value: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">x, y</span>) </span>{
    <span class="hljs-keyword">if</span> (x === y) {
      <span class="hljs-comment">// 针对+0 不等于 -0的情况</span>
      <span class="hljs-keyword">return</span> x !== <span class="hljs-built_in">0</span> || <span class="hljs-built_in">1</span> / x === <span class="hljs-built_in">1</span> / y;
    }
    <span class="hljs-comment">// 针对NaN的情况</span>
    <span class="hljs-keyword">return</span> x !== x &amp;&amp; y !== y;
  },
  configurable: <span class="hljs-built_in">true</span>,
  enumerable: <span class="hljs-built_in">false</span>,
  writable: <span class="hljs-built_in">true</span>
});
</code></pre>
<h2 id="objectassign" class="calibre13">Object.assign()</h2>
<h3 id="基本用法" class="calibre12">基本用法</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> target = { a: <span class="hljs-built_in">1</span> };

<span class="hljs-keyword">var</span> source1 = { b: <span class="hljs-built_in">2</span> };
<span class="hljs-keyword">var</span> source2 = { c: <span class="hljs-built_in">3</span> };

<span class="hljs-built_in">Object</span>.assign(target, source1, source2);
target <span class="hljs-comment">// {a:1, b:2, c:3}</span>
</code></pre>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p class="calibre7">注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> target = { a: <span class="hljs-built_in">1</span>, b: <span class="hljs-built_in">1</span> };

<span class="hljs-keyword">var</span> source1 = { b: <span class="hljs-built_in">2</span>, c: <span class="hljs-built_in">2</span> };
<span class="hljs-keyword">var</span> source2 = { c: <span class="hljs-built_in">3</span> };

<span class="hljs-built_in">Object</span>.assign(target, source1, source2);
target <span class="hljs-comment">// {a:1, b:2, c:3}</span>
</code></pre>
<p class="calibre7">如果只有一个参数，<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>会直接返回该参数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = {a: <span class="hljs-built_in">1</span>};
<span class="hljs-built_in">Object</span>.assign(obj) === obj <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre7">如果该参数不是对象，则会先转成对象，然后返回。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">2</span>) <span class="hljs-comment">// "object"</span>
</code></pre>
<p class="calibre7">由于<code class="pcalibre3 pcalibre4 calibre14">undefined</code>和<code class="pcalibre3 pcalibre4 calibre14">null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">undefined</span>) <span class="hljs-comment">// 报错</span>
<span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">null</span>) <span class="hljs-comment">// 报错</span>
</code></pre>
<p class="calibre7">如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code class="pcalibre3 pcalibre4 calibre14">undefined</code>和<code class="pcalibre3 pcalibre4 calibre14">null</code>不在首参数，就不会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> obj = {a: <span class="hljs-built_in">1</span>};
<span class="hljs-built_in">Object</span>.assign(obj, <span class="hljs-built_in">undefined</span>) === obj <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Object</span>.assign(obj, <span class="hljs-built_in">null</span>) === obj <span class="hljs-comment">// true</span>
</code></pre>
<p class="calibre7">其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> v1 = <span class="hljs-string">'abc'</span>;
<span class="hljs-keyword">var</span> v2 = <span class="hljs-built_in">true</span>;
<span class="hljs-keyword">var</span> v3 = <span class="hljs-built_in">10</span>;

<span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.assign({}, v1, v2, v3);
<span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// { "0": "a", "1": "b", "2": "c" }</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">v1</code>、<code class="pcalibre3 pcalibre4 calibre14">v2</code>、<code class="pcalibre3 pcalibre4 calibre14">v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>(<span class="hljs-built_in">true</span>) <span class="hljs-comment">// {[[PrimitiveValue]]: true}</span>
<span class="hljs-built_in">Object</span>(<span class="hljs-built_in">10</span>)  <span class="hljs-comment">//  {[[PrimitiveValue]]: 10}</span>
<span class="hljs-built_in">Object</span>(<span class="hljs-string">'abc'</span>) <span class="hljs-comment">// {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}</span>
</code></pre>
<p class="calibre7">上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code class="pcalibre3 pcalibre4 calibre14">[[PrimitiveValue]]</code>上面，这个属性是不会被<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code class="pcalibre3 pcalibre4 calibre14">enumerable: false</code>）。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.assign({b: <span class="hljs-string">'c'</span>},
  <span class="hljs-built_in">Object</span>.defineProperty({}, <span class="hljs-string">'invisible'</span>, {
    enumerable: <span class="hljs-built_in">false</span>,
    value: <span class="hljs-string">'hello'</span>
  })
)
<span class="hljs-comment">// { b: 'c' }</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>要拷贝的对象只有一个不可枚举属性<code class="pcalibre3 pcalibre4 calibre14">invisible</code>，这个属性并没有被拷贝进去。</p>
<p class="calibre7">属性名为Symbol值的属性，也会被<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>拷贝。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.assign({ a: <span class="hljs-string">'b'</span> }, { [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'c'</span>)]: <span class="hljs-string">'d'</span> })
<span class="hljs-comment">// { a: 'b', Symbol(c): 'd' }</span>
</code></pre>
<h3 id="注意点" class="calibre12">注意点</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj1 = {a: {b: <span class="hljs-built_in">1</span>}};
<span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Object</span>.assign({}, obj1);

obj1.a.b = <span class="hljs-built_in">2</span>;
obj2.a.b <span class="hljs-comment">// 2</span>
</code></pre>
<p class="calibre7">上面代码中，源对象<code class="pcalibre3 pcalibre4 calibre14">obj1</code>的<code class="pcalibre3 pcalibre4 calibre14">a</code>属性的值是一个对象，<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<p class="calibre7">对于这种嵌套的对象，一旦遇到同名属性，<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>的处理方法是替换，而不是添加。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> target = { a: { b: <span class="hljs-string">'c'</span>, d: <span class="hljs-string">'e'</span> } }
<span class="hljs-keyword">var</span> source = { a: { b: <span class="hljs-string">'hello'</span> } }
<span class="hljs-built_in">Object</span>.assign(target, source)
<span class="hljs-comment">// { a: { b: 'hello' } }</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">target</code>对象的<code class="pcalibre3 pcalibre4 calibre14">a</code>属性被<code class="pcalibre3 pcalibre4 calibre14">source</code>对象的<code class="pcalibre3 pcalibre4 calibre14">a</code>属性整个替换掉了，而不会得到<code class="pcalibre3 pcalibre4 calibre14">{ a: { b: 'hello', d: 'e' } }</code>的结果。这通常不是开发者想要的，需要特别小心。</p>
<p class="calibre7">有一些函数库提供<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>的定制版本（比如Lodash的<code class="pcalibre3 pcalibre4 calibre14">_.defaultsDeep</code>方法），可以解决浅拷贝的问题，得到深拷贝的合并。</p>
<p class="calibre7">注意，<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.assign([<span class="hljs-built_in">1</span>, <span class="hljs-built_in">2</span>, <span class="hljs-built_in">3</span>], [<span class="hljs-built_in">4</span>, <span class="hljs-built_in">5</span>])
<span class="hljs-comment">// [4, 5, 3]</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>把数组视为属性名为0、1、2的对象，因此目标数组的0号属性<code class="pcalibre3 pcalibre4 calibre14">4</code>覆盖了原数组的0号属性<code class="pcalibre3 pcalibre4 calibre14">1</code>。</p>
<h3 id="常见用途" class="calibre12">常见用途</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法有很多用处。</p>
<p class="calibre7"><strong class="calibre17">（1）为对象添加属性</strong></p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-operator"><span class="hljs-keyword">class</span> <span class="hljs-comment">Point</span> </span>{
  constructor(x, y) {
    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-keyword">this</span>, {x, y});
  }
}
</code></pre>
<p class="calibre7">上面方法通过<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法，将<code class="pcalibre3 pcalibre4 calibre14">x</code>属性和<code class="pcalibre3 pcalibre4 calibre14">y</code>属性添加到<code class="pcalibre3 pcalibre4 calibre14">Point</code>类的对象实例。</p>
<p class="calibre7"><strong class="calibre17">（2）为对象添加方法</strong></p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

<span class="hljs-comment">// 等同于下面的写法</span>
SomeClass.prototype.someMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">arg1, arg2</span>) </span>{
  ···
};
SomeClass.prototype.anotherMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>) </span>{
  ···
};
</code></pre>
<p class="calibre7">上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。</p>
<p class="calibre7"><strong class="calibre17">（3）克隆对象</strong></p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">clone</span>(<span class="hljs-built_in">origin</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, origin);
}
</code></pre>
<p class="calibre7">上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p class="calibre7">不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">clone</span>(<span class="hljs-built_in">origin</span>) </span>{
  <span class="hljs-keyword">let</span> originProto = <span class="hljs-built_in">Object</span>.getPrototypeOf(origin);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">Object</span>.create(originProto), origin);
}
</code></pre>
<p class="calibre7"><strong class="calibre17">（4）合并多个对象</strong></p>
<p class="calibre7">将多个对象合并到某个对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> merge =
  (target, ...sources) =&gt; <span class="hljs-built_in">Object</span>.assign(target, ...sources);
</code></pre>
<p class="calibre7">如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> merge =
  (...sources) =&gt; <span class="hljs-built_in">Object</span>.assign({}, ...sources);
</code></pre>
<p class="calibre7"><strong class="calibre17">（5）为属性指定默认值</strong></p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> DEFAULTS = {
  logLevel: <span class="hljs-built_in">0</span>,
  outputFormat: <span class="hljs-string">'html'</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">processContent</span>(<span class="hljs-built_in">options</span>) </span>{
  <span class="hljs-keyword">let</span> options = <span class="hljs-built_in">Object</span>.assign({}, DEFAULTS, options);
}
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">DEFAULTS</code>对象是默认值，<code class="pcalibre3 pcalibre4 calibre14">options</code>对象是用户提供的参数。<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法将<code class="pcalibre3 pcalibre4 calibre14">DEFAULTS</code>和<code class="pcalibre3 pcalibre4 calibre14">options</code>合并成一个新对象，如果两者有同名属性，则<code class="pcalibre3 pcalibre4 calibre14">option</code>的属性值会覆盖<code class="pcalibre3 pcalibre4 calibre14">DEFAULTS</code>的属性值。</p>
<p class="calibre7">注意，由于存在深拷贝的问题，<code class="pcalibre3 pcalibre4 calibre14">DEFAULTS</code>对象和<code class="pcalibre3 pcalibre4 calibre14">options</code>对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致<code class="pcalibre3 pcalibre4 calibre14">DEFAULTS</code>对象的该属性不起作用。</p>
<h2 id="属性的可枚举性" class="calibre13">属性的可枚举性</h2>
<p class="calibre7">对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> obj = { foo: <span class="hljs-built_in">123</span> };
 <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">'foo'</span>)
 <span class="hljs-comment">//   { value: 123,</span>
 <span class="hljs-comment">//     writable: true,</span>
 <span class="hljs-comment">//     enumerable: true,</span>
 <span class="hljs-comment">//     configurable: true }</span>
</code></pre>
<p class="calibre7">描述对象的<code class="pcalibre3 pcalibre4 calibre14">enumerable</code>属性，称为”可枚举性“，如果该属性为<code class="pcalibre3 pcalibre4 calibre14">false</code>，就表示某些操作会忽略当前属性。</p>
<p class="calibre7">ES5有三个操作会忽略<code class="pcalibre3 pcalibre4 calibre14">enumerable</code>为<code class="pcalibre3 pcalibre4 calibre14">false</code>的属性。</p>
<ul class="calibre10">
<li class="calibre11">for...in 循环：只遍历对象自身的和继承的可枚举的属性</li>
<li class="calibre11">Object.keys()：返回对象自身的所有可枚举的属性的键名</li>
<li class="calibre11">JSON.stringify()：只串行化对象自身的可枚举的属性</li>
</ul>
<p class="calibre7">ES6新增了两个操作，会忽略<code class="pcalibre3 pcalibre4 calibre14">enumerable</code>为<code class="pcalibre3 pcalibre4 calibre14">false</code>的属性。</p>
<ul class="calibre10">
<li class="calibre11">Object.assign()：只拷贝对象自身的可枚举的属性</li>
<li class="calibre11">Reflect.enumerate()：返回所有<code class="pcalibre3 pcalibre4 calibre14">for...in</code>循环会遍历的属性</li>
</ul>
<p class="calibre7">这五个操作之中，只有<code class="pcalibre3 pcalibre4 calibre14">for...in</code>和<code class="pcalibre3 pcalibre4 calibre14">Reflect.enumerate()</code>会返回继承的属性。实际上，引入<code class="pcalibre3 pcalibre4 calibre14">enumerable</code>的最初目的，就是让某些属性可以规避掉<code class="pcalibre3 pcalibre4 calibre14">for...in</code>操作。比如，对象原型的<code class="pcalibre3 pcalibre4 calibre14">toString</code>方法，以及数组的<code class="pcalibre3 pcalibre4 calibre14">length</code>属性，就通过这种手段，不会被<code class="pcalibre3 pcalibre4 calibre14">for...in</code>遍历到。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">Object</span>.prototype, <span class="hljs-string">'toString'</span>).enumerable
<span class="hljs-comment">// false</span>

<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor([], <span class="hljs-string">'length'</span>).enumerable
<span class="hljs-comment">// false</span>
</code></pre>
<p class="calibre7">另外，ES6规定，所有Class的原型的方法都是不可枚举的。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-operator"><span class="hljs-keyword">class</span> </span>{foo() {}}.prototype, <span class="hljs-string">'foo'</span>).enumerable
<span class="hljs-comment">// false</span>
</code></pre>
<p class="calibre7">总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code class="pcalibre3 pcalibre4 calibre14">for...in</code>循环，而用<code class="pcalibre3 pcalibre4 calibre14">Object.keys()</code>代替。</p>
<h2 id="属性的遍历" class="calibre13">属性的遍历</h2>
<p class="calibre7">ES6一共有6种方法可以遍历对象的属性。</p>
<p class="calibre7"><strong class="calibre17">（1）for...in</strong></p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">for...in</code>循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>
<p class="calibre7"><strong class="calibre17">（2）Object.keys(obj)</strong></p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p>
<p class="calibre7"><strong class="calibre17">（3）Object.getOwnPropertyNames(obj)</strong></p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p>
<p class="calibre7"><strong class="calibre17">（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有Symbol属性。</p>
<p class="calibre7"><strong class="calibre17">（5）Reflect.ownKeys(obj)</strong></p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Reflect.ownKeys</code>返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</p>
<p class="calibre7"><strong class="calibre17">（6）Reflect.enumerate(obj)</strong></p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Reflect.enumerate</code>返回一个Iterator对象，遍历对象自身的和继承的所有可枚举属性（不含Symbol属性），与<code class="pcalibre3 pcalibre4 calibre14">for...in</code>循环相同。</p>
<p class="calibre7">以上的6种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。</p>
<ul class="calibre10">
<li class="calibre11">首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li class="calibre11">其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li class="calibre11">最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Reflect</span>.ownKeys({ [<span class="hljs-built_in">Symbol</span>()]:<span class="hljs-built_in">0</span>, b:<span class="hljs-built_in">0</span>, <span class="hljs-built_in">10</span>:<span class="hljs-built_in">0</span>, <span class="hljs-built_in">2</span>:<span class="hljs-built_in">0</span>, a:<span class="hljs-built_in">0</span> })
<span class="hljs-comment">// ['2', '10', 'b', 'a', Symbol()]</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code class="pcalibre3 pcalibre4 calibre14">2</code>和<code class="pcalibre3 pcalibre4 calibre14">10</code>，其次是字符串属性<code class="pcalibre3 pcalibre4 calibre14">b</code>和<code class="pcalibre3 pcalibre4 calibre14">a</code>，最后是Symbol属性。</p>
<h2 id="proto属性，objectsetprototypeof，objectgetprototypeof" class="calibre13"><code class="pcalibre3 calibre19 pcalibre4">__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2>
<p class="calibre7"><strong class="calibre17">（1）<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>属性</strong></p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的<code class="pcalibre3 pcalibre4 calibre14">prototype</code>对象。目前，所有浏览器（包括IE11）都部署了这个属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// es6的写法</span>
<span class="hljs-keyword">var</span> obj = {
  method: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{ ... }
};
obj.__proto__ = someOtherObj;

<span class="hljs-comment">// es5的写法</span>
<span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(someOtherObj);
obj.method = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{ ... };
</code></pre>
<p class="calibre7">该属性没有写入ES6的正文，而是写入了附录，原因是<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code class="pcalibre3 pcalibre4 calibre14">Object.setPrototypeOf()</code>（写操作）、<code class="pcalibre3 pcalibre4 calibre14">Object.getPrototypeOf()</code>（读操作）、<code class="pcalibre3 pcalibre4 calibre14">Object.create()</code>（生成操作）代替。</p>
<p class="calibre7">在实现上，<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>调用的是<code class="pcalibre3 pcalibre4 calibre14">Object.prototype.__proto__</code>，具体实现如下。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Object</span>.prototype, <span class="hljs-string">'__proto__'</span>, {
  get() {
    <span class="hljs-keyword">let</span> _thisObj = <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getPrototypeOf(_thisObj);
  },
  set(proto) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> === <span class="hljs-built_in">undefined</span> || <span class="hljs-keyword">this</span> === <span class="hljs-built_in">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>();
    }
    <span class="hljs-keyword">if</span> (!isObject(<span class="hljs-keyword">this</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">undefined</span>;
    }
    <span class="hljs-keyword">if</span> (!isObject(proto)) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">undefined</span>;
    }
    <span class="hljs-keyword">let</span> status = <span class="hljs-built_in">Reflect</span>.setPrototypeOf(<span class="hljs-keyword">this</span>, proto);
    <span class="hljs-keyword">if</span> (!status) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>();
    }
  },
});
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">isObject</span>(<span class="hljs-built_in">value</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>(value) === value;
}
</code></pre>
<p class="calibre7">如果一个对象本身部署了<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>属性，则该属性的值就是对象的原型。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.getPrototypeOf({ __proto__: <span class="hljs-built_in">null</span> })
<span class="hljs-comment">// null</span>
</code></pre>
<p class="calibre7"><strong class="calibre17">（2）Object.setPrototypeOf()</strong></p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.setPrototypeOf</code>方法的作用与<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>相同，用来设置一个对象的<code class="pcalibre3 pcalibre4 calibre14">prototype</code>对象。它是ES6正式推荐的设置原型对象的方法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 格式</span>
<span class="hljs-built_in">Object</span>.setPrototypeOf(object, prototype)

<span class="hljs-comment">// 用法</span>
<span class="hljs-keyword">var</span> o = <span class="hljs-built_in">Object</span>.setPrototypeOf({}, <span class="hljs-built_in">null</span>);
</code></pre>
<p class="calibre7">该方法等同于下面的函数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">obj, proto</span>) </span>{
  obj.__proto__ = proto;
  <span class="hljs-keyword">return</span> obj;
}
</code></pre>
<p class="calibre7">下面是一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> proto = {};
<span class="hljs-keyword">let</span> obj = { x: <span class="hljs-built_in">10</span> };
<span class="hljs-built_in">Object</span>.setPrototypeOf(obj, proto);

proto.y = <span class="hljs-built_in">20</span>;
proto.z = <span class="hljs-built_in">40</span>;

obj.x <span class="hljs-comment">// 10</span>
obj.y <span class="hljs-comment">// 20</span>
obj.z <span class="hljs-comment">// 40</span>
</code></pre>
<p class="calibre7">上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</p>
<p class="calibre7"><strong class="calibre17">（3）Object.getPrototypeOf()</strong></p>
<p class="calibre7">该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.getPrototypeOf(obj);
</code></pre>
<p class="calibre7">下面是一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">Rectangle</span>(<span class="hljs-built_in"></span>) </span>{
}

<span class="hljs-keyword">var</span> rec = <span class="hljs-keyword">new</span> Rectangle();

<span class="hljs-built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype
<span class="hljs-comment">// true</span>

<span class="hljs-built_in">Object</span>.setPrototypeOf(rec, <span class="hljs-built_in">Object</span>.prototype);
<span class="hljs-built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype
<span class="hljs-comment">// false</span>
</code></pre>
<h2 id="objectvalues，objectentries" class="calibre13">Object.values()，Object.entries()</h2>
<h3 id="objectkeys" class="calibre12">Object.keys()</h3>
<p class="calibre7">ES5引入了<code class="pcalibre3 pcalibre4 calibre14">Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = { foo: <span class="hljs-string">"bar"</span>, baz: <span class="hljs-built_in">42</span> };
<span class="hljs-built_in">Object</span>.keys(obj)
<span class="hljs-comment">// ["foo", "baz"]</span>
</code></pre>
<p class="calibre7">目前，ES7有一个<a target="_blank" href="https://github.com/tc39/proposal-object-values-entries" class="calibre8 pcalibre1 pcalibre2 pcalibre">提案</a>，引入了跟<code class="pcalibre3 pcalibre4 calibre14">Object.keys</code>配套的<code class="pcalibre3 pcalibre4 calibre14">Object.values</code>和<code class="pcalibre3 pcalibre4 calibre14">Object.entries</code>。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> {keys, values, entries} = <span class="hljs-built_in">Object</span>;
<span class="hljs-keyword">let</span> obj = { a: <span class="hljs-built_in">1</span>, b: <span class="hljs-built_in">2</span>, c: <span class="hljs-built_in">3</span> };

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> keys(obj)) {
  <span class="hljs-built_in">console</span>.log(key); <span class="hljs-comment">// 'a', 'b', 'c'</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> values(obj)) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 1, 2, 3</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> entries(obj)) {
  <span class="hljs-built_in">console</span>.log([key, value]); <span class="hljs-comment">// ['a', 1], ['b', 2], ['c', 3]</span>
}
</code></pre>
<h3 id="objectvalues" class="calibre12">Object.values()</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = { foo: <span class="hljs-string">"bar"</span>, baz: <span class="hljs-built_in">42</span> };
<span class="hljs-built_in">Object</span>.values(obj)
<span class="hljs-comment">// ["bar", 42]</span>
</code></pre>
<p class="calibre7">返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = { <span class="hljs-built_in">100</span>: <span class="hljs-string">'a'</span>, <span class="hljs-built_in">2</span>: <span class="hljs-string">'b'</span>, <span class="hljs-built_in">7</span>: <span class="hljs-string">'c'</span> };
<span class="hljs-built_in">Object</span>.values(obj)
<span class="hljs-comment">// ["b", "c", "a"]</span>
</code></pre>
<p class="calibre7">上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code class="pcalibre3 pcalibre4 calibre14">b</code>、<code class="pcalibre3 pcalibre4 calibre14">c</code>、<code class="pcalibre3 pcalibre4 calibre14">a</code>。</p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.values</code>只返回对象自身的可遍历属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create({}, {p: {value: <span class="hljs-built_in">42</span>}});
<span class="hljs-built_in">Object</span>.values(obj) <span class="hljs-comment">// []</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">Object.create</code>方法的第二个参数添加的对象属性（属性<code class="pcalibre3 pcalibre4 calibre14">p</code>），如果不显式声明，默认是不可遍历的。<code class="pcalibre3 pcalibre4 calibre14">Object.values</code>不会返回这个属性。</p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.values</code>会过滤属性名为Symbol值的属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.values({ [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-built_in">123</span>, foo: <span class="hljs-string">'abc'</span> });
<span class="hljs-comment">// ['abc']</span>
</code></pre>
<p class="calibre7">如果<code class="pcalibre3 pcalibre4 calibre14">Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.values(<span class="hljs-string">'foo'</span>)
<span class="hljs-comment">// ['f', 'o', 'o']</span>
</code></pre>
<p class="calibre7">上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code class="pcalibre3 pcalibre4 calibre14">Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p class="calibre7">如果参数不是对象，<code class="pcalibre3 pcalibre4 calibre14">Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code class="pcalibre3 pcalibre4 calibre14">Object.values</code>会返回空数组。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.values(<span class="hljs-built_in">42</span>) <span class="hljs-comment">// []</span>
<span class="hljs-built_in">Object</span>.values(<span class="hljs-built_in">true</span>) <span class="hljs-comment">// []</span>
</code></pre>
<h3 id="objectentries" class="calibre12">Object.entries</h3>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = { foo: <span class="hljs-string">'bar'</span>, baz: <span class="hljs-built_in">42</span> };
<span class="hljs-built_in">Object</span>.entries(obj)
<span class="hljs-comment">// [ ["foo", "bar"], ["baz", 42] ]</span>
</code></pre>
<p class="calibre7">除了返回值不一样，该方法的行为与<code class="pcalibre3 pcalibre4 calibre14">Object.values</code>基本一致。</p>
<p class="calibre7">如果原对象的属性名是一个Symbol值，该属性会被省略。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-built_in">Object</span>.entries({ [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-built_in">123</span>, foo: <span class="hljs-string">'abc'</span> });
<span class="hljs-comment">// [ [ 'foo', 'abc' ] ]</span>
</code></pre>
<p class="calibre7">上面代码中，原对象有两个属性，<code class="pcalibre3 pcalibre4 calibre14">Object.entries</code>只输出属性名非Symbol值的属性。将来可能会有<code class="pcalibre3 pcalibre4 calibre14">Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.entries</code>的基本用途是遍历对象的属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> obj = { one: <span class="hljs-built_in">1</span>, two: <span class="hljs-built_in">2</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-operator">${JSON.stringify(k)}</span>: <span class="hljs-operator">${JSON.stringify(v)}</span>`</span>);
}
<span class="hljs-comment">// "one": 1</span>
<span class="hljs-comment">// "two": 2</span>
</code></pre>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.entries</code>方法的一个用处是，将对象转为真正的<code class="pcalibre3 pcalibre4 calibre14">Map</code>结构。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = { foo: <span class="hljs-string">'bar'</span>, baz: <span class="hljs-built_in">42</span> };
<span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(obj));
map <span class="hljs-comment">// Map { foo: "bar", baz: 42 }</span>
</code></pre>
<p class="calibre7">自己实现<code class="pcalibre3 pcalibre4 calibre14">Object.entries</code>方法，非常简单。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// Generator函数的版本</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-comment">entries</span>(<span class="hljs-built_in">obj</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) {
    <span class="hljs-keyword">yield</span> [key, obj[key]];
  }
}

<span class="hljs-comment">// 非Generator函数的版本</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">entries</span>(<span class="hljs-built_in">obj</span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) [key, obj[key]]);
}
</code></pre>
<h2 id="对象的扩展运算符" class="calibre13">对象的扩展运算符</h2>
<p class="calibre7">目前，ES7有一个<a target="_blank" href="https://github.com/sebmarkbage/ecmascript-rest-spread" class="calibre8 pcalibre1 pcalibre2 pcalibre">提案</a>，将Rest解构赋值/扩展运算符（...）引入对象。Babel转码器已经支持这项功能。</p>
<p class="calibre7"><strong class="calibre17">（1）Rest解构赋值</strong></p>
<p class="calibre7">对象的Rest解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> { x, y, ...z } = { x: <span class="hljs-built_in">1</span>, y: <span class="hljs-built_in">2</span>, a: <span class="hljs-built_in">3</span>, b: <span class="hljs-built_in">4</span> };
x <span class="hljs-comment">// 1</span>
y <span class="hljs-comment">// 2</span>
z <span class="hljs-comment">// { a: 3, b: 4 }</span>
</code></pre>
<p class="calibre7">上面代码中，变量<code class="pcalibre3 pcalibre4 calibre14">z</code>是Rest解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code class="pcalibre3 pcalibre4 calibre14">a</code>和<code class="pcalibre3 pcalibre4 calibre14">b</code>），将它们和它们的值拷贝过来。</p>
<p class="calibre7">由于Rest解构赋值要求等号右边是一个对象，所以如果等号右边是<code class="pcalibre3 pcalibre4 calibre14">undefined</code>或<code class="pcalibre3 pcalibre4 calibre14">null</code>，就会报错，因为它们无法转为对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> { x, y, ...z } = <span class="hljs-built_in">null</span>; <span class="hljs-comment">// 运行时错误</span>
<span class="hljs-keyword">let</span> { x, y, ...z } = <span class="hljs-built_in">undefined</span>; <span class="hljs-comment">// 运行时错误</span>
</code></pre>
<p class="calibre7">Rest解构赋值必须是最后一个参数，否则会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> { ...x, y, z } = obj; <span class="hljs-comment">// 句法错误</span>
<span class="hljs-keyword">let</span> { x, ...y, ...z } = obj; <span class="hljs-comment">// 句法错误</span>
</code></pre>
<p class="calibre7">上面代码中，Rest解构赋值不是最后一个参数，所以会报错。</p>
<p class="calibre7">注意，Rest解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么Rest解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> obj = { a: { b: <span class="hljs-built_in">1</span> } };
<span class="hljs-keyword">let</span> { ...x } = obj;
obj.a.b = <span class="hljs-built_in">2</span>;
x.a.b <span class="hljs-comment">// 2</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">x</code>是Rest解构赋值所在的对象，拷贝了对象<code class="pcalibre3 pcalibre4 calibre14">obj</code>的<code class="pcalibre3 pcalibre4 calibre14">a</code>属性。<code class="pcalibre3 pcalibre4 calibre14">a</code>属性引用了一个对象，修改这个对象的值，会影响到Rest解构赋值对它的引用。</p>
<p class="calibre7">另外，Rest解构赋不会拷贝继承自原型对象的属性。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> o1 = { a: <span class="hljs-built_in">1</span> };
<span class="hljs-keyword">let</span> o2 = { b: <span class="hljs-built_in">2</span> };
o2.__proto__ = o1;
<span class="hljs-keyword">let</span> o3 = { ...o2 };
o3 <span class="hljs-comment">// { b: 2 }</span>
</code></pre>
<p class="calibre7">上面代码中，对象<code class="pcalibre3 pcalibre4 calibre14">o3</code>是<code class="pcalibre3 pcalibre4 calibre14">o2</code>的拷贝，但是只复制了<code class="pcalibre3 pcalibre4 calibre14">o2</code>自身的属性，没有复制它的原型对象<code class="pcalibre3 pcalibre4 calibre14">o1</code>的属性。</p>
<p class="calibre7">下面是另一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> o = <span class="hljs-built_in">Object</span>.create({ x: <span class="hljs-built_in">1</span>, y: <span class="hljs-built_in">2</span> });
o.z = <span class="hljs-built_in">3</span>;

<span class="hljs-keyword">let</span> { x, ...{ y, z } } = o;
x <span class="hljs-comment">// 1</span>
y <span class="hljs-comment">// undefined</span>
z <span class="hljs-comment">// 3</span>
</code></pre>
<p class="calibre7">上面代码中，变量<code class="pcalibre3 pcalibre4 calibre14">x</code>是单纯的解构赋值，所以可以读取继承的属性；Rest解构赋值产生的变量<code class="pcalibre3 pcalibre4 calibre14">y</code>和<code class="pcalibre3 pcalibre4 calibre14">z</code>，只能读取对象自身的属性，所以只有变量<code class="pcalibre3 pcalibre4 calibre14">z</code>可以赋值成功。</p>
<p class="calibre7">Rest解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">baseFunction</span>(<span class="hljs-built_in">{ a, b }</span>) </span>{
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">wrapperFunction</span>(<span class="hljs-built_in">{ x, y, ...restConfig }</span>) </span>{
  <span class="hljs-comment">// 使用x和y参数进行操作</span>
  <span class="hljs-comment">// 其余参数传给原始函数</span>
  <span class="hljs-keyword">return</span> baseFunction(restConfig);
}
</code></pre>
<p class="calibre7">上面代码中，原始函数<code class="pcalibre3 pcalibre4 calibre14">baseFunction</code>接受<code class="pcalibre3 pcalibre4 calibre14">a</code>和<code class="pcalibre3 pcalibre4 calibre14">b</code>作为参数，函数<code class="pcalibre3 pcalibre4 calibre14">wrapperFunction</code>在<code class="pcalibre3 pcalibre4 calibre14">baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<p class="calibre7"><strong class="calibre17">（2）扩展运算符</strong></p>
<p class="calibre7">扩展运算符（<code class="pcalibre3 pcalibre4 calibre14">...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> z = { a: <span class="hljs-built_in">3</span>, b: <span class="hljs-built_in">4</span> };
<span class="hljs-keyword">let</span> n = { ...z };
n <span class="hljs-comment">// { a: 3, b: 4 }</span>
</code></pre>
<p class="calibre7">这等同于使用<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> aClone = { ...a };
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> aClone = <span class="hljs-built_in">Object</span>.assign({}, a);
</code></pre>
<p class="calibre7">扩展运算符可以用于合并两个对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> ab = { ...a, ...b };
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> ab = <span class="hljs-built_in">Object</span>.assign({}, a, b);
</code></pre>
<p class="calibre7">如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> aWithOverrides = { ...a, x: <span class="hljs-built_in">1</span>, y: <span class="hljs-built_in">2</span> };
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> aWithOverrides = { ...a, ...{ x: <span class="hljs-built_in">1</span>, y: <span class="hljs-built_in">2</span> } };
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-built_in">1</span>, y = <span class="hljs-built_in">2</span>, aWithOverrides = { ...a, x, y };
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> aWithOverrides = <span class="hljs-built_in">Object</span>.assign({}, a, { x: <span class="hljs-built_in">1</span>, y: <span class="hljs-built_in">2</span> });
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">a</code>对象的<code class="pcalibre3 pcalibre4 calibre14">x</code>属性和<code class="pcalibre3 pcalibre4 calibre14">y</code>属性，拷贝到新对象后会被覆盖掉。</p>
<p class="calibre7">这用来修改现有对象部分的部分属性就很方便了。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> newVersion = {
  ...previousVersion,
  name: <span class="hljs-string">'New Name'</span> <span class="hljs-comment">// Override the name property</span>
};
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">newVersion</code>对象自定义了<code class="pcalibre3 pcalibre4 calibre14">name</code>属性，其他属性全部复制自<code class="pcalibre3 pcalibre4 calibre14">previousVersion</code>对象。</p>
<p class="calibre7">如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> aWithDefaults = { x: <span class="hljs-built_in">1</span>, y: <span class="hljs-built_in">2</span>, ...a };
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> aWithDefaults = <span class="hljs-built_in">Object</span>.assign({}, { x: <span class="hljs-built_in">1</span>, y: <span class="hljs-built_in">2</span> }, a);
<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> aWithDefaults = <span class="hljs-built_in">Object</span>.assign({ x: <span class="hljs-built_in">1</span>, y: <span class="hljs-built_in">2</span> }, a);
</code></pre>
<p class="calibre7">扩展运算符的参数对象之中，如果有取值函数<code class="pcalibre3 pcalibre4 calibre14">get</code>，这个函数是会执行的。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 并不会抛出错误，因为x属性只是被定义，但没执行</span>
<span class="hljs-keyword">let</span> aWithXGetter = {
  ...a,
  get x() {
    throws <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'not thrown yet'</span>);
  }
};

<span class="hljs-comment">// 会抛出错误，因为x属性被执行了</span>
<span class="hljs-keyword">let</span> runtimeError = {
  ...a,
  ...{
    get x() {
      throws <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'thrown now'</span>);
    }
  }
};
</code></pre>
<p class="calibre7">如果扩展运算符的参数是<code class="pcalibre3 pcalibre4 calibre14">null</code>或<code class="pcalibre3 pcalibre4 calibre14">undefined</code>，这个两个值会被忽略，不会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> emptyObject = { ...null, ...undefined }; <span class="hljs-comment">// 不报错</span>
</code></pre>
<h2 id="objectgetownpropertydescriptors" class="calibre13">Object.getOwnPropertyDescriptors()</h2>
<p class="calibre7">ES5有一个<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptor</code>方法，返回某个对象属性的描述对象（descriptor）。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> obj = { p: <span class="hljs-string">'a'</span> };

<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">'p'</span>)
<span class="hljs-comment">// Object { value: "a",</span>
<span class="hljs-comment">//   writable: true,</span>
<span class="hljs-comment">//   enumerable: true,</span>
<span class="hljs-comment">//   configurable: true</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p class="calibre7">ES7有一个提案，提出了<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> obj = {
  foo: <span class="hljs-built_in">123</span>,
  get bar() { <span class="hljs-keyword">return</span> <span class="hljs-string">'abc'</span> }
};

<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj)
<span class="hljs-comment">// { foo:</span>
<span class="hljs-comment">//    { value: 123,</span>
<span class="hljs-comment">//      writable: true,</span>
<span class="hljs-comment">//      enumerable: true,</span>
<span class="hljs-comment">//      configurable: true },</span>
<span class="hljs-comment">//   bar:</span>
<span class="hljs-comment">//    { get: [Function: bar],</span>
<span class="hljs-comment">//      set: undefined,</span>
<span class="hljs-comment">//      enumerable: true,</span>
<span class="hljs-comment">//      configurable: true } }</span>
</code></pre>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptors</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p class="calibre7">该方法的实现非常容易。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">getOwnPropertyDescriptors</span>(<span class="hljs-built_in">obj</span>) </span>{
  <span class="hljs-keyword">const</span> result = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(obj)) {
    result[key] = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, key);
  }
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p class="calibre7">该方法的提出目的，主要是为了解决<code class="pcalibre3 pcalibre4 calibre14">Object.assign()</code>无法正确拷贝<code class="pcalibre3 pcalibre4 calibre14">get</code>属性和<code class="pcalibre3 pcalibre4 calibre14">set</code>属性的问题。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> source = {
  set foo(value) {
    <span class="hljs-built_in">console</span>.log(value);
  }
};

<span class="hljs-keyword">const</span> target1 = {};
<span class="hljs-built_in">Object</span>.assign(target1, source);

<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target1, <span class="hljs-string">'foo'</span>)
<span class="hljs-comment">// { value: undefined,</span>
<span class="hljs-comment">//   writable: true,</span>
<span class="hljs-comment">//   enumerable: true,</span>
<span class="hljs-comment">//   configurable: true }</span>
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">source</code>对象的<code class="pcalibre3 pcalibre4 calibre14">foo</code>属性的值是一个赋值函数，<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法将这个属性拷贝给<code class="pcalibre3 pcalibre4 calibre14">target1</code>对象，结果该属性的值变成了<code class="pcalibre3 pcalibre4 calibre14">undefined</code>。这是因为<code class="pcalibre3 pcalibre4 calibre14">Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p class="calibre7">这时，<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptors</code>方法配合<code class="pcalibre3 pcalibre4 calibre14">Object.defineProperties</code>方法，就可以实现正确拷贝。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> source = {
  set foo(value) {
    <span class="hljs-built_in">console</span>.log(value);
  }
};

<span class="hljs-keyword">const</span> target2 = {};
<span class="hljs-built_in">Object</span>.defineProperties(target2, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source));
<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target2, <span class="hljs-string">'foo'</span>)
<span class="hljs-comment">// { get: undefined,</span>
<span class="hljs-comment">//   set: [Function: foo],</span>
<span class="hljs-comment">//   enumerable: true,</span>
<span class="hljs-comment">//   configurable: true }</span>
</code></pre>
<p class="calibre7">上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> shallowMerge = (target, source) =&gt; <span class="hljs-built_in">Object</span>.defineProperties(
  target,
  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)
);
</code></pre>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptors</code>方法的另一个用处，是配合<code class="pcalibre3 pcalibre4 calibre14">Object.create</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> clone = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj),
  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj));

<span class="hljs-comment">// 或者</span>

<span class="hljs-keyword">const</span> shallowClone = (obj) =&gt; <span class="hljs-built_in">Object</span>.create(
  <span class="hljs-built_in">Object</span>.getPrototypeOf(obj),
  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj)
);
</code></pre>
<p class="calibre7">上面代码会克隆对象<code class="pcalibre3 pcalibre4 calibre14">obj</code>。</p>
<p class="calibre7">另外，<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptors</code>方法可以实现，一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> obj = {
  __proto__: prot,
  foo: <span class="hljs-built_in">123</span>,
};
</code></pre>
<p class="calibre7">ES6规定<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code class="pcalibre3 pcalibre4 calibre14">__proto__</code>，上面代码就要改成下面这样。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(prot);
obj.foo = <span class="hljs-built_in">123</span>;

<span class="hljs-comment">// 或者</span>

<span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.assign(
  <span class="hljs-built_in">Object</span>.create(prot),
  {
    foo: <span class="hljs-built_in">123</span>,
  }
);
</code></pre>
<p class="calibre7">有了<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptors</code>，我们就有了另一种写法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(
  prot,
  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors({
    foo: <span class="hljs-built_in">123</span>,
  })
);
</code></pre>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptors</code>也可以用来实现Mixin（混入）模式。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> mix = (object) =&gt; ({
  <span class="hljs-keyword">with</span>: (...mixins) =&gt; mixins.reduce(
    (c, mixin) =&gt; <span class="hljs-built_in">Object</span>.create(
      c, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(mixin)
    ), object)
});

<span class="hljs-comment">// multiple mixins example</span>
<span class="hljs-keyword">let</span> a = {a: <span class="hljs-string">'a'</span>};
<span class="hljs-keyword">let</span> b = {b: <span class="hljs-string">'b'</span>};
<span class="hljs-keyword">let</span> c = {c: <span class="hljs-string">'c'</span>};
<span class="hljs-keyword">let</span> d = mix(c).with(a, b);
</code></pre>
<p class="calibre7">上面代码中，对象<code class="pcalibre3 pcalibre4 calibre14">a</code>和<code class="pcalibre3 pcalibre4 calibre14">b</code>被混入了对象<code class="pcalibre3 pcalibre4 calibre14">c</code>。</p>
<p class="calibre7">出于完整性的考虑，<code class="pcalibre3 pcalibre4 calibre14">Object.getOwnPropertyDescriptors</code>进入标准以后，还会有<code class="pcalibre3 pcalibre4 calibre14">Reflect.getOwnPropertyDescriptors</code>方法。</p>

            
            </div>
        
    
</div>

        
        
    
    

</body></html>
