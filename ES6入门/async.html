<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>异步操作和Async函数 | ECMAScript 6入门</title>
    <meta name="description" content=""/>
    <meta name="generator" content="GitBook 2.6.7"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="dir">
        
        
<div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_17">异步操作和Async函数</h1>
        
            <div class="section" id="section-">
            
                <h1 id="异步操作和async函数" class="calibre6">异步操作和Async函数</h1>
<p class="calibre7">异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。</p>
<p class="calibre7">ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<ul class="calibre10">
<li class="calibre11">回调函数</li>
<li class="calibre11">事件监听</li>
<li class="calibre11">发布/订阅</li>
<li class="calibre11">Promise 对象</li>
</ul>
<p class="calibre7">ES6将JavaScript异步编程带入了一个全新的阶段，ES7的<code class="pcalibre3 pcalibre4 calibre14">Async</code>函数更是提出了异步编程的终极解决方案。</p>
<h2 id="基本概念" class="calibre13">基本概念</h2>
<h3 id="异步" class="calibre12">异步</h3>
<p class="calibre7">所谓"异步"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p class="calibre7">比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p class="calibre7">相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h3 id="回调函数" class="calibre12">回调函数</h3>
<p class="calibre7">JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是"重新调用"。</p>
<p class="calibre7">读取文件进行处理，是这样写的。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">fs.readFile(<span class="hljs-string">'/etc/passwd'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">err, data</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(data);
});
</code></pre>
<p class="calibre7">上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code class="pcalibre3 pcalibre4 calibre14">/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
<p class="calibre7">一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h3 id="promise" class="calibre12">Promise</h3>
<p class="calibre7">回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">fs.readFile(fileA, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">err, data</span>) </span>{
  fs.readFile(fileB, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">err, data</span>) </span>{
    <span class="hljs-comment">// ...</span>
  });
});
</code></pre>
<p class="calibre7">不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为"回调函数噩梦"（callback hell）。</p>
<p class="calibre7">Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> readFile = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs-readfile-promise'</span>);

readFile(fileA)
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">data</span>)</span>{
  <span class="hljs-built_in">console</span>.log(data.toString());
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-keyword">return</span> readFile(fileB);
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">data</span>)</span>{
  <span class="hljs-built_in">console</span>.log(data.toString());
})
.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">err</span>) </span>{
  <span class="hljs-built_in">console</span>.log(err);
});
</code></pre>
<p class="calibre7">上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p>
<p class="calibre7">可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p class="calibre7">Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<p class="calibre7">那么，有没有更好的写法呢？</p>
<h2 id="generator函数" class="calibre13">Generator函数</h2>
<h3 id="协程" class="calibre12">协程</h3>
<p class="calibre7">传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做"协程"（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p class="calibre7">协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<ul class="calibre10">
<li class="calibre11">第一步，协程A开始执行。</li>
<li class="calibre11">第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</li>
<li class="calibre11">第三步，（一段时间后）协程B交还执行权。</li>
<li class="calibre11">第四步，协程A恢复执行。</li>
</ul>
<p class="calibre7">上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p class="calibre7">举例来说，读取文件的协程写法如下。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-comment">asnycJob</span>(<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-comment">// ...其他代码</span>
  <span class="hljs-keyword">var</span> f = <span class="hljs-keyword">yield</span> readFile(fileA);
  <span class="hljs-comment">// ...其他代码</span>
}
</code></pre>
<p class="calibre7">上面代码的函数<code class="pcalibre3 pcalibre4 calibre14">asyncJob</code>是一个协程，它的奥妙就在其中的<code class="pcalibre3 pcalibre4 calibre14">yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code class="pcalibre3 pcalibre4 calibre14">yield</code>命令是异步两个阶段的分界线。</p>
<p class="calibre7">协程遇到<code class="pcalibre3 pcalibre4 calibre14">yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h3 id="generator函数的概念" class="calibre12">Generator函数的概念</h3>
<p class="calibre7">Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p class="calibre7">整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code class="pcalibre3 pcalibre4 calibre14">yield</code>语句注明。Generator函数的执行方法如下。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-comment">gen</span>(<span class="hljs-built_in">x</span>)</span>{
  <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-built_in">2</span>;
  <span class="hljs-keyword">return</span> y;
}

<span class="hljs-keyword">var</span> g = gen(<span class="hljs-built_in">1</span>);
g.next() <span class="hljs-comment">// { value: 3, done: false }</span>
g.next() <span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<p class="calibre7">上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到<code class="pcalibre3 pcalibre4 calibre14">x + 2</code>为止。</p>
<p class="calibre7">换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<h3 id="generator函数的数据交换和错误处理" class="calibre12">Generator函数的数据交换和错误处理</h3>
<p class="calibre7">Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p class="calibre7">next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-comment">gen</span>(<span class="hljs-built_in">x</span>)</span>{
  <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-built_in">2</span>;
  <span class="hljs-keyword">return</span> y;
}

<span class="hljs-keyword">var</span> g = gen(<span class="hljs-built_in">1</span>);
g.next() <span class="hljs-comment">// { value: 3, done: false }</span>
g.next(<span class="hljs-built_in">2</span>) <span class="hljs-comment">// { value: 2, done: true }</span>
</code></pre>
<p class="calibre7">上面代码中，第一个next方法的value属性，返回表达式<code class="pcalibre3 pcalibre4 calibre14">x + 2</code>的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p>
<p class="calibre7">Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-comment">gen</span>(<span class="hljs-built_in">x</span>)</span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-built_in">2</span>;
  } <span class="hljs-keyword">catch</span> (e){
    <span class="hljs-built_in">console</span>.log(e);
  }
  <span class="hljs-keyword">return</span> y;
}

<span class="hljs-keyword">var</span> g = gen(<span class="hljs-built_in">1</span>);
g.next();
g.throw(<span class="hljs-string">'出错了'</span>);
<span class="hljs-comment">// 出错了</span>
</code></pre>
<p class="calibre7">上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try ...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h3 id="异步任务的封装" class="calibre12">异步任务的封装</h3>
<p class="calibre7">下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> fetch = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-fetch'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-comment">gen</span>(<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-keyword">var</span> url = <span class="hljs-string">'https://api.github.com/users/github'</span>;
  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">yield</span> fetch(url);
  <span class="hljs-built_in">console</span>.log(result.bio);
}
</code></pre>
<p class="calibre7">上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p>
<p class="calibre7">执行这段代码的方法如下。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> g = gen();
<span class="hljs-keyword">var</span> result = g.next();

result.value.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">data</span>)</span>{
  <span class="hljs-keyword">return</span> data.json();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">data</span>)</span>{
  g.next(data);
});
</code></pre>
<p class="calibre7">上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p>
<p class="calibre7">可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h2 id="thunk函数" class="calibre13">Thunk函数</h2>
<h3 id="参数的求值策略" class="calibre12">参数的求值策略</h3>
<p class="calibre7">Thunk函数早在上个世纪60年代就诞生了。</p>
<p class="calibre7">那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是"求值策略"，即函数的参数到底应该何时求值。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> x = <span class="hljs-built_in">1</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">f</span>(<span class="hljs-built_in">m</span>)</span>{
  <span class="hljs-keyword">return</span> m * <span class="hljs-built_in">2</span>;
}

f(x + <span class="hljs-built_in">5</span>)
</code></pre>
<p class="calibre7">上面代码先定义函数f，然后向它传入表达式<code class="pcalibre3 pcalibre4 calibre14">x + 5</code>。请问，这个表达式应该何时求值？</p>
<p class="calibre7">一种意见是"传值调用"（call by value），即在进入函数体之前，就计算<code class="pcalibre3 pcalibre4 calibre14">x + 5</code>的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">f(x + <span class="hljs-built_in">5</span>)
<span class="hljs-comment">// 传值调用时，等同于</span>
f(<span class="hljs-built_in">6</span>)
</code></pre>
<p class="calibre7">另一种意见是"传名调用"（call by name），即直接将表达式<code class="pcalibre3 pcalibre4 calibre14">x + 5</code>传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">f(x + <span class="hljs-built_in">5</span>)
<span class="hljs-comment">// 传名调用时，等同于</span>
(x + <span class="hljs-built_in">5</span>) * <span class="hljs-built_in">2</span>
</code></pre>
<p class="calibre7">传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">f</span>(<span class="hljs-built_in">a, b</span>)</span>{
  <span class="hljs-keyword">return</span> b;
}

f(<span class="hljs-built_in">3</span> * x * x - <span class="hljs-built_in">2</span> * x - <span class="hljs-built_in">1</span>, x);
</code></pre>
<p class="calibre7">上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于"传名调用"，即只在执行时求值。</p>
<h3 id="thunk函数的含义" class="calibre12">Thunk函数的含义</h3>
<p class="calibre7">编译器的"传名调用"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">f</span>(<span class="hljs-built_in">m</span>)</span>{
  <span class="hljs-keyword">return</span> m * <span class="hljs-built_in">2</span>;
}

f(x + <span class="hljs-built_in">5</span>);

<span class="hljs-comment">// 等同于</span>

<span class="hljs-keyword">var</span> thunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-keyword">return</span> x + <span class="hljs-built_in">5</span>;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">f</span>(<span class="hljs-built_in">thunk</span>)</span>{
  <span class="hljs-keyword">return</span> thunk() * <span class="hljs-built_in">2</span>;
}
</code></pre>
<p class="calibre7">上面代码中，函数f的参数<code class="pcalibre3 pcalibre4 calibre14">x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code class="pcalibre3 pcalibre4 calibre14">Thunk</code>函数求值即可。
这就是Thunk函数的定义，它是"传名调用"的一种实现策略，用来替换某个表达式。</p>
<h3 id="javascript语言的thunk函数" class="calibre12">JavaScript语言的Thunk函数</h3>
<p class="calibre7">JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 正常版本的readFile（多参数版本）</span>
fs.readFile(fileName, callback);

<span class="hljs-comment">// Thunk版本的readFile（单参数版本）</span>
<span class="hljs-keyword">var</span> readFileThunk = Thunk(fileName);
readFileThunk(callback);

<span class="hljs-keyword">var</span> Thunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">fileName</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">callback</span>)</span>{
    <span class="hljs-keyword">return</span> fs.readFile(fileName, callback);
  };
};
</code></pre>
<p class="calibre7">上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p>
<p class="calibre7">任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> Thunk = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">fn</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>)</span>{
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">callback</span>)</span>{
      args.push(callback);
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args);
    }
  };
};
</code></pre>
<p class="calibre7">使用上面的转换器，生成<code class="pcalibre3 pcalibre4 calibre14">fs.readFile</code>的Thunk函数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> readFileThunk = Thunk(fs.readFile);
readFileThunk(fileA)(callback);
</code></pre>
<h3 id="thunkify模块" class="calibre12">Thunkify模块</h3>
<p class="calibre7">生产环境的转换器，建议使用Thunkify模块。</p>
<p class="calibre7">首先是安装。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">$ npm install thunkify
</code></pre>
<p class="calibre7">使用方式如下。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> thunkify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'thunkify'</span>);
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">var</span> read = thunkify(fs.readFile);
read(<span class="hljs-string">'package.json'</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">err, str</span>)</span>{
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<p class="calibre7">Thunkify的源码与上一节那个简单的转换器非常像。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">thunkify</span>(<span class="hljs-built_in">fn</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>)</span>{
    <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length);
    <span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-built_in">0</span>; i &lt; args.length; ++i) {
      args[i] = <span class="hljs-built_in">arguments</span>[i];
    }

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">done</span>)</span>{
      <span class="hljs-keyword">var</span> called;

      args.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>)</span>{
        <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;
        called = <span class="hljs-built_in">true</span>;
        done.apply(<span class="hljs-built_in">null</span>, <span class="hljs-built_in">arguments</span>);
      });

      <span class="hljs-keyword">try</span> {
        fn.apply(ctx, args);
      } <span class="hljs-keyword">catch</span> (err) {
        done(err);
      }
    }
  }
};
</code></pre>
<p class="calibre7">它的源码主要多了一个检查机制，变量<code class="pcalibre3 pcalibre4 calibre14">called</code>确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">f</span>(<span class="hljs-built_in">a, b, callback</span>)</span>{
  <span class="hljs-keyword">var</span> sum = a + b;
  callback(sum);
  callback(sum);
}

<span class="hljs-keyword">var</span> ft = thunkify(f);
<span class="hljs-keyword">var</span> print = <span class="hljs-built_in">console</span>.log.bind(<span class="hljs-built_in">console</span>);
ft(<span class="hljs-built_in">1</span>, <span class="hljs-built_in">2</span>)(print);
<span class="hljs-comment">// 3</span>
</code></pre>
<p class="calibre7">上面代码中，由于<code class="pcalibre3 pcalibre4 calibre14">thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p>
<h3 id="generator-函数的流程管理" class="calibre12">Generator 函数的流程管理</h3>
<p class="calibre7">你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p>
<p class="calibre7">以读取文件为例。下面的Generator函数封装了两个异步操作。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">var</span> thunkify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'thunkify'</span>);
<span class="hljs-keyword">var</span> readFile = thunkify(fs.readFile);

<span class="hljs-keyword">var</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-keyword">var</span> r1 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'/etc/fstab'</span>);
  <span class="hljs-built_in">console</span>.log(r1.toString());
  <span class="hljs-keyword">var</span> r2 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'/etc/shells'</span>);
  <span class="hljs-built_in">console</span>.log(r2.toString());
};
</code></pre>
<p class="calibre7">上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p>
<p class="calibre7">这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> g = gen();

<span class="hljs-keyword">var</span> r1 = g.next();
r1.value(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">err, data</span>)</span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-keyword">var</span> r2 = g.next(data);
  r2.value(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">err, data</span>)</span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    g.next(data);
  });
});
</code></pre>
<p class="calibre7">上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。</p>
<p class="calibre7">仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。</p>
<h3 id="thunk函数的自动流程管理" class="calibre12">Thunk函数的自动流程管理</h3>
<p class="calibre7">Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">run</span>(<span class="hljs-built_in">fn</span>) </span>{
  <span class="hljs-keyword">var</span> gen = fn();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">next</span>(<span class="hljs-built_in">err, data</span>) </span>{
    <span class="hljs-keyword">var</span> result = gen.next(data);
    <span class="hljs-keyword">if</span> (result.done) <span class="hljs-keyword">return</span>;
    result.value(next);
  }

  next();
}

run(gen);
</code></pre>
<p class="calibre7">上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done 属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。</p>
<p class="calibre7">有了这个执行器，执行Generator函数方便多了。不管有多少个异步操作，直接传入<code class="pcalibre3 pcalibre4 calibre14">run</code>函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在<code class="pcalibre3 pcalibre4 calibre14">yield</code>命令后面的必须是Thunk函数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'fileA'</span>);
  <span class="hljs-keyword">var</span> f2 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'fileB'</span>);
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'fileN'</span>);
};

run(gen);
</code></pre>
<p class="calibre7">上面代码中，函数<code class="pcalibre3 pcalibre4 calibre14">gen</code>封装了<code class="pcalibre3 pcalibre4 calibre14">n</code>个异步的读取文件操作，只要执行<code class="pcalibre3 pcalibre4 calibre14">run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p class="calibre7">Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h2 id="co模块" class="calibre13">co模块</h2>
<h3 id="基本用法" class="calibre12">基本用法</h3>
<p class="calibre7"><a target="_blank" href="https://github.com/tj/co" class="calibre8 pcalibre1 pcalibre2 pcalibre">co模块</a>是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p>
<p class="calibre7">比如，有一个Generator函数，用于依次读取两个文件。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'/etc/fstab'</span>);
  <span class="hljs-keyword">var</span> f2 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'/etc/shells'</span>);
  <span class="hljs-built_in">console</span>.log(f1.toString());
  <span class="hljs-built_in">console</span>.log(f2.toString());
};
</code></pre>
<p class="calibre7">co模块可以让你不用编写Generator函数的执行器。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
co(gen);
</code></pre>
<p class="calibre7">上面代码中，Generator函数只要传入co函数，就会自动执行。</p>
<p class="calibre7">co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">co(gen).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Generator 函数执行完成'</span>);
})
</code></pre>
<p class="calibre7">上面代码中，等到Generator函数执行结束，就会输出一行提示。</p>
<h3 id="co模块的原理" class="calibre12">co模块的原理</h3>
<p class="calibre7">为什么co可以自动执行Generator函数？</p>
<p class="calibre7">前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p class="calibre7">两种方法可以做到这一点。</p>
<p class="calibre7">（1）回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</p>
<p class="calibre7">（2）Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</p>
<p class="calibre7">co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p>
<p class="calibre7">上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p>
<h3 id="基于promise对象的自动执行" class="calibre12">基于Promise对象的自动执行</h3>
<p class="calibre7">还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">var</span> readFile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">fileName</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">resolve, reject</span>)</span>{
    fs.readFile(fileName, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">error, data</span>)</span>{
      <span class="hljs-keyword">if</span> (error) reject(error);
      resolve(data);
    });
  });
};

<span class="hljs-keyword">var</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'/etc/fstab'</span>);
  <span class="hljs-keyword">var</span> f2 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'/etc/shells'</span>);
  <span class="hljs-built_in">console</span>.log(f1.toString());
  <span class="hljs-built_in">console</span>.log(f2.toString());
};
</code></pre>
<p class="calibre7">然后，手动执行上面的Generator函数。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> g = gen();

g.next().value.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">data</span>)</span>{
  g.next(data).value.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">data</span>)</span>{
    g.next(data);
  });
})
</code></pre>
<p class="calibre7">手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">run</span>(<span class="hljs-built_in">gen</span>)</span>{
  <span class="hljs-keyword">var</span> g = gen();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">next</span>(<span class="hljs-built_in">data</span>)</span>{
    <span class="hljs-keyword">var</span> result = g.next(data);
    <span class="hljs-keyword">if</span> (result.done) <span class="hljs-keyword">return</span> result.value;
    result.value.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">data</span>)</span>{
      next(data);
    });
  }

  next();
}

run(gen);
</code></pre>
<p class="calibre7">上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>
<h3 id="co模块的源码" class="calibre12">co模块的源码</h3>
<p class="calibre7">co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>
<p class="calibre7">首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">co</span>(<span class="hljs-built_in">gen</span>) </span>{
  <span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">resolve, reject</span>) </span>{
  });
}
</code></pre>
<p class="calibre7">在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">co</span>(<span class="hljs-built_in">gen</span>) </span>{
  <span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">resolve, reject</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> gen === <span class="hljs-string">'function'</span>) gen = gen.call(ctx);
    <span class="hljs-keyword">if</span> (!gen || <span class="hljs-keyword">typeof</span> gen.next !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span> resolve(gen);
  });
}
</code></pre>
<p class="calibre7">接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">co</span>(<span class="hljs-built_in">gen</span>) </span>{
  <span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">resolve, reject</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> gen === <span class="hljs-string">'function'</span>) gen = gen.call(ctx);
    <span class="hljs-keyword">if</span> (!gen || <span class="hljs-keyword">typeof</span> gen.next !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span> resolve(gen);

    onFulfilled();
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">onFulfilled</span>(<span class="hljs-built_in">res</span>) </span>{
      <span class="hljs-keyword">var</span> ret;
      <span class="hljs-keyword">try</span> {
        ret = gen.next(res);
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> reject(e);
      }
      next(ret);
    }
  });
}
</code></pre>
<p class="calibre7">最后，就是关键的next函数，它会反复调用自身。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">next</span>(<span class="hljs-built_in">ret</span>) </span>{
  <span class="hljs-keyword">if</span> (ret.done) <span class="hljs-keyword">return</span> resolve(ret.value);
  <span class="hljs-keyword">var</span> value = toPromise.call(ctx, ret.value);
  <span class="hljs-keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="hljs-keyword">return</span> value.then(onFulfilled, onRejected);
  <span class="hljs-keyword">return</span> onRejected(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'You may only yield a function, promise, generator, array, or object, '</span>
    + <span class="hljs-string">'but the following object was passed: "'</span> + <span class="hljs-built_in">String</span>(ret.value) + <span class="hljs-string">'"'</span>));
}
</code></pre>
<p class="calibre7">上面代码中，next 函数的内部代码，一共只有四行命令。</p>
<p class="calibre7">第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p class="calibre7">第二行，确保每一步的返回值，是 Promise 对象。</p>
<p class="calibre7">第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p>
<p class="calibre7">第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p>
<h3 id="处理并发的异步操作" class="calibre12">处理并发的异步操作</h3>
<p class="calibre7">co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p class="calibre7">这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 数组的写法</span>
co(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">yield</span> [
    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">1</span>),
    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">2</span>)
  ];
  <span class="hljs-built_in">console</span>.log(res);
}).catch(onerror);

<span class="hljs-comment">// 对象的写法</span>
co(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">yield</span> {
    <span class="hljs-built_in">1</span>: <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">1</span>),
    <span class="hljs-built_in">2</span>: <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">2</span>),
  };
  <span class="hljs-built_in">console</span>.log(res);
}).catch(onerror);
</code></pre>
<p class="calibre7">下面是另一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6">co(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-keyword">var</span> values = [n1, n2, n3];
  <span class="hljs-keyword">yield</span> values.map(somethingAsync);
});

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-comment">somethingAsync</span>(<span class="hljs-built_in">x</span>) </span>{
  <span class="hljs-comment">// do something async</span>
  <span class="hljs-keyword">return</span> y
}
</code></pre>
<p class="calibre7">上面的代码允许并发三个<code class="pcalibre3 pcalibre4 calibre14">somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p>
<h2 id="async函数" class="calibre13">async函数</h2>
<h3 id="含义" class="calibre12">含义</h3>
<p class="calibre7">ES7提供了<code class="pcalibre3 pcalibre4 calibre14">async</code>函数，使得异步操作变得更加方便。<code class="pcalibre3 pcalibre4 calibre14">async</code>函数是什么？一句话，<code class="pcalibre3 pcalibre4 calibre14">async</code>函数就是Generator函数的语法糖。</p>
<p class="calibre7">前文有一个Generator函数，依次读取两个文件。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">var</span> readFile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">fileName</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">resolve, reject</span>)</span>{
    fs.readFile(fileName, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">error, data</span>)</span>{
      <span class="hljs-keyword">if</span> (error) reject(error);
      resolve(data);
    });
  });
};

<span class="hljs-keyword">var</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'/etc/fstab'</span>);
  <span class="hljs-keyword">var</span> f2 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">'/etc/shells'</span>);
  <span class="hljs-built_in">console</span>.log(f1.toString());
  <span class="hljs-built_in">console</span>.log(f2.toString());
};
</code></pre>
<p class="calibre7">写成<code class="pcalibre3 pcalibre4 calibre14">async</code>函数，就是下面这样。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> asyncReadFile = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>)</span>{
  <span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">'/etc/fstab'</span>);
  <span class="hljs-keyword">var</span> f2 = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">'/etc/shells'</span>);
  <span class="hljs-built_in">console</span>.log(f1.toString());
  <span class="hljs-built_in">console</span>.log(f2.toString());
};
</code></pre>
<p class="calibre7">一比较就会发现，<code class="pcalibre3 pcalibre4 calibre14">async</code>函数就是将Generator函数的星号（<code class="pcalibre3 pcalibre4 calibre14">*</code>）替换成<code class="pcalibre3 pcalibre4 calibre14">async</code>，将<code class="pcalibre3 pcalibre4 calibre14">yield</code>替换成<code class="pcalibre3 pcalibre4 calibre14">await</code>，仅此而已。</p>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">async</code>函数对 Generator 函数的改进，体现在以下四点。</p>
<p class="calibre7">（1）内置执行器。Generator函数的执行必须靠执行器，所以才有了<code class="pcalibre3 pcalibre4 calibre14">co</code>模块，而<code class="pcalibre3 pcalibre4 calibre14">async</code>函数自带执行器。也就是说，<code class="pcalibre3 pcalibre4 calibre14">async</code>函数的执行，与普通函数一模一样，只要一行。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">var</span> result = asyncReadFile();
</code></pre>
<p class="calibre7">上面的代码调用了<code class="pcalibre3 pcalibre4 calibre14">asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用<code class="pcalibre3 pcalibre4 calibre14">next</code>方法，或者用<code class="pcalibre3 pcalibre4 calibre14">co</code>模块，才能得到真正执行，得到最后结果。</p>
<p class="calibre7">（2）更好的语义。<code class="pcalibre3 pcalibre4 calibre14">async</code>和<code class="pcalibre3 pcalibre4 calibre14">await</code>，比起星号和<code class="pcalibre3 pcalibre4 calibre14">yield</code>，语义更清楚了。<code class="pcalibre3 pcalibre4 calibre14">async</code>表示函数里有异步操作，<code class="pcalibre3 pcalibre4 calibre14">await</code>表示紧跟在后面的表达式需要等待结果。</p>
<p class="calibre7">（3）更广的适用性。 <code class="pcalibre3 pcalibre4 calibre14">co</code>模块约定，<code class="pcalibre3 pcalibre4 calibre14">yield</code>命令后面只能是Thunk函数或Promise对象，而<code class="pcalibre3 pcalibre4 calibre14">async</code>函数的<code class="pcalibre3 pcalibre4 calibre14">await</code>命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p class="calibre7">（4）返回值是Promise。<code class="pcalibre3 pcalibre4 calibre14">async</code>函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用<code class="pcalibre3 pcalibre4 calibre14">then</code>方法指定下一步的操作。</p>
<p class="calibre7">进一步说，<code class="pcalibre3 pcalibre4 calibre14">async</code>函数完全可以看作多个异步操作，包装成的一个Promise对象，而<code class="pcalibre3 pcalibre4 calibre14">await</code>命令就是内部<code class="pcalibre3 pcalibre4 calibre14">then</code>命令的语法糖。</p>
<p class="calibre7">正常情况下，<code class="pcalibre3 pcalibre4 calibre14">await</code>命令后面是一个Promise对象，否则会被转成Promise。</p>
<p class="calibre7">下面是一个完整的例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">getTitle</span>(<span class="hljs-built_in">url</span>) </span>{
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);
  <span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> response.text();
  <span class="hljs-keyword">return</span> html.match(<span class="hljs-tag">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="hljs-built_in">1</span>];
}
getTitle(<span class="hljs-string">'https://tc39.github.io/ecma262/'</span>).then(<span class="hljs-built_in">console</span>.log)
<span class="hljs-comment">// "ECMAScript 2017 Language Specification"</span>
</code></pre>
<h3 id="async函数的实现" class="calibre12">async函数的实现</h3>
<p class="calibre7">async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">fn</span>(<span class="hljs-built_in">args</span>)</span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 等同于</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">fn</span>(<span class="hljs-built_in">args</span>)</span>{
  <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-built_in"></span>) </span>{
    <span class="hljs-comment">// ...</span>
  });
}
</code></pre>
<p class="calibre7">所有的<code class="pcalibre3 pcalibre4 calibre14">async</code>函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>
<p class="calibre7">下面给出<code class="pcalibre3 pcalibre4 calibre14">spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">spawn</span>(<span class="hljs-built_in">genF</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">resolve, reject</span>) </span>{
    <span class="hljs-keyword">var</span> gen = genF();
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">step</span>(<span class="hljs-built_in">nextF</span>) </span>{
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> next = nextF();
      } <span class="hljs-keyword">catch</span>(e) {
        <span class="hljs-keyword">return</span> reject(e);
      }
      <span class="hljs-keyword">if</span>(next.done) {
        <span class="hljs-keyword">return</span> resolve(next.value);
      }
      <span class="hljs-built_in">Promise</span>.resolve(next.value).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">v</span>) </span>{
        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(v); });
      }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">e</span>) </span>{
        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{ <span class="hljs-keyword">return</span> gen.throw(e); });
      });
    }
    step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(<span class="hljs-built_in">undefined</span>); });
  });
}
</code></pre>
<p class="calibre7"><code class="pcalibre3 pcalibre4 calibre14">async</code>函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器<code class="pcalibre3 pcalibre4 calibre14">Babel</code>和<code class="pcalibre3 pcalibre4 calibre14">regenerator</code>都已经支持，转码后就能使用。</p>
<h3 id="async-函数的用法" class="calibre12">async 函数的用法</h3>
<p class="calibre7">同Generator函数一样，<code class="pcalibre3 pcalibre4 calibre14">async</code>函数返回一个Promise对象，可以使用<code class="pcalibre3 pcalibre4 calibre14">then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code class="pcalibre3 pcalibre4 calibre14">await</code>就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p class="calibre7">下面是一个例子。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">getStockPriceByName</span>(<span class="hljs-built_in">name</span>) </span>{
  <span class="hljs-keyword">var</span> symbol = <span class="hljs-keyword">await</span> getStockSymbol(name);
  <span class="hljs-keyword">var</span> stockPrice = <span class="hljs-keyword">await</span> getStockPrice(symbol);
  <span class="hljs-keyword">return</span> stockPrice;
}

getStockPriceByName(<span class="hljs-string">'goog'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">result</span>) </span>{
  <span class="hljs-built_in">console</span>.log(result);
});
</code></pre>
<p class="calibre7">上面代码是一个获取股票报价的函数，函数前面的<code class="pcalibre3 pcalibre4 calibre14">async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code class="pcalibre3 pcalibre4 calibre14">Promise</code>对象。</p>
<p class="calibre7">下面的例子，指定多少毫秒后输出一个值。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">timeout</span>(<span class="hljs-built_in">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve) =&gt; {
    setTimeout(resolve, ms);
  });
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">asyncPrint</span>(<span class="hljs-built_in">value, ms</span>) </span>{
  <span class="hljs-keyword">await</span> timeout(ms);
  <span class="hljs-built_in">console</span>.log(value)
}

asyncPrint(<span class="hljs-string">'hello world'</span>, <span class="hljs-built_in">50</span>);
</code></pre>
<p class="calibre7">上面代码指定50毫秒以后，输出"hello world"。</p>
<p class="calibre7">Async函数有多种使用形式。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 函数声明</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">foo</span>(<span class="hljs-built_in"></span>) </span>{}

<span class="hljs-comment">// 函数表达式</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in"></span>) </span>{};

<span class="hljs-comment">// 对象的方法</span>
<span class="hljs-keyword">let</span> obj = { <span class="hljs-keyword">async</span> foo() {} }

<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">async</span> () =&gt; {};
</code></pre>
<h3 id="注意点" class="calibre12">注意点</h3>
<p class="calibre7">第一点，<code class="pcalibre3 pcalibre4 calibre14">await</code>命令后面的Promise对象，运行结果可能是rejected，所以最好把<code class="pcalibre3 pcalibre4 calibre14">await</code>命令放在<code class="pcalibre3 pcalibre4 calibre14">try...catch</code>代码块中。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">myFunction</span>(<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> somethingThatReturnsAPromise();
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.log(err);
  }
}

<span class="hljs-comment">// 另一种写法</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">myFunction</span>(<span class="hljs-built_in"></span>) </span>{
  <span class="hljs-keyword">await</span> somethingThatReturnsAPromise().catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">err</span>)</span>{
    <span class="hljs-built_in">console</span>.log(err);
  };
}
</code></pre>
<p class="calibre7">第二点，多个<code class="pcalibre3 pcalibre4 calibre14">await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> getFoo();
<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> getBar();
</code></pre>
<p class="calibre7">上面代码中，<code class="pcalibre3 pcalibre4 calibre14">getFoo</code>和<code class="pcalibre3 pcalibre4 calibre14">getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code class="pcalibre3 pcalibre4 calibre14">getFoo</code>完成以后，才会执行<code class="pcalibre3 pcalibre4 calibre14">getBar</code>，完全可以让它们同时触发。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">let</span> [foo, bar] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([getFoo(), getBar()]);

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">let</span> fooPromise = getFoo();
<span class="hljs-keyword">let</span> barPromise = getBar();
<span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> fooPromise;
<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> barPromise;
</code></pre>
<p class="calibre7">上面两种写法，<code class="pcalibre3 pcalibre4 calibre14">getFoo</code>和<code class="pcalibre3 pcalibre4 calibre14">getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>
<p class="calibre7">第三点，<code class="pcalibre3 pcalibre4 calibre14">await</code>命令只能用在<code class="pcalibre3 pcalibre4 calibre14">async</code>函数之中，如果用在普通函数，就会报错。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">dbFuc</span>(<span class="hljs-built_in">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];

  <span class="hljs-comment">// 报错</span>
  docs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">doc</span>) </span>{
    <span class="hljs-keyword">await</span> db.post(doc);
  });
}
</code></pre>
<p class="calibre7">上面代码会报错，因为await用在普通函数之中了。但是，如果将<code class="pcalibre3 pcalibre4 calibre14">forEach</code>方法的参数改成<code class="pcalibre3 pcalibre4 calibre14">async</code>函数，也有问题。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">dbFuc</span>(<span class="hljs-built_in">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];

  <span class="hljs-comment">// 可能得到错误结果</span>
  docs.forEach(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-built_in">doc</span>) </span>{
    <span class="hljs-keyword">await</span> db.post(doc);
  });
}
</code></pre>
<p class="calibre7">上面代码可能不会正常工作，原因是这时三个<code class="pcalibre3 pcalibre4 calibre14">db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code class="pcalibre3 pcalibre4 calibre14">for</code>循环。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">dbFuc</span>(<span class="hljs-built_in">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> doc <span class="hljs-keyword">of</span> docs) {
    <span class="hljs-keyword">await</span> db.post(doc);
  }
}
</code></pre>
<p class="calibre7">如果确实希望多个请求并发执行，可以使用<code class="pcalibre3 pcalibre4 calibre14">Promise.all</code>方法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">dbFuc</span>(<span class="hljs-built_in">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];
  <span class="hljs-keyword">let</span> promises = docs.map((doc) =&gt; db.post(doc));

  <span class="hljs-keyword">let</span> results = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
  <span class="hljs-built_in">console</span>.log(results);
}

<span class="hljs-comment">// 或者使用下面的写法</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">dbFuc</span>(<span class="hljs-built_in">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];
  <span class="hljs-keyword">let</span> promises = docs.map((doc) =&gt; db.post(doc));

  <span class="hljs-keyword">let</span> results = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises) {
    results.push(<span class="hljs-keyword">await</span> promise);
  }
  <span class="hljs-built_in">console</span>.log(results);
}
</code></pre>
<p class="calibre7">ES6将<code class="pcalibre3 pcalibre4 calibre14">await</code>增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。</p>
<h3 id="与promise、generator的比较" class="calibre12">与Promise、Generator的比较</h3>
<p class="calibre7">我们通过一个例子，来看Async函数与Promise、Generator函数的区别。</p>
<p class="calibre7">假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p class="calibre7">首先是Promise的写法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">chainAnimationsPromise</span>(<span class="hljs-built_in">elem, animations</span>) </span>{

  <span class="hljs-comment">// 变量ret用来保存上一个动画的返回值</span>
  <span class="hljs-keyword">var</span> ret = <span class="hljs-built_in">null</span>;

  <span class="hljs-comment">// 新建一个空的Promise</span>
  <span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Promise</span>.resolve();

  <span class="hljs-comment">// 使用then方法，添加所有动画</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> anim <span class="hljs-keyword">in</span> animations) {
    p = p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">val</span>) </span>{
      ret = val;
      <span class="hljs-keyword">return</span> anim(elem);
    })
  }

  <span class="hljs-comment">// 返回一个部署了错误捕捉机制的Promise</span>
  <span class="hljs-keyword">return</span> p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in">e</span>) </span>{
    <span class="hljs-comment">/* 忽略错误，继续执行 */</span>
  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-built_in"></span>) </span>{
    <span class="hljs-keyword">return</span> ret;
  });

}
</code></pre>
<p class="calibre7">虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。</p>
<p class="calibre7">接着是Generator函数的写法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">chainAnimationsGenerator</span>(<span class="hljs-built_in">elem, animations</span>) </span>{

  <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-built_in"></span>) </span>{
    <span class="hljs-keyword">var</span> ret = <span class="hljs-built_in">null</span>;
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> anim <span class="hljs-keyword">of</span> animations) {
        ret = <span class="hljs-keyword">yield</span> anim(elem);
      }
    } <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-comment">/* 忽略错误，继续执行 */</span>
    }
      <span class="hljs-keyword">return</span> ret;
  });

}
</code></pre>
<p class="calibre7">上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。</p>
<p class="calibre7">最后是Async函数的写法。</p>
<pre class="calibre15"><code class="lang-bash pcalibre5 pcalibre6"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-comment">chainAnimationsAsync</span>(<span class="hljs-built_in">elem, animations</span>) </span>{
  <span class="hljs-keyword">var</span> ret = <span class="hljs-built_in">null</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> anim <span class="hljs-keyword">of</span> animations) {
      ret = <span class="hljs-keyword">await</span> anim(elem);
    }
  } <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-comment">/* 忽略错误，继续执行 */</span>
  }
  <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<p class="calibre7">可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>

            
            </div>
        
    
</div>

        
        
    
    

</body></html>
